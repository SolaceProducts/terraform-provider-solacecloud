// Package missioncontrol provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package missioncontrol

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for BrokerMonitoringMode.
const (
	ADVANCED BrokerMonitoringMode = "ADVANCED"
	BASIC    BrokerMonitoringMode = "BASIC"
)

// Defines values for CertificateType.
const (
	CUSTOM        CertificateType = "CUSTOM"
	SOLACEMANAGED CertificateType = "SOLACE_MANAGED"
)

// Defines values for ConnectionEndpointAccessType.
const (
	PRIVATE ConnectionEndpointAccessType = "PRIVATE"
	PUBLIC  ConnectionEndpointAccessType = "PUBLIC"
)

// Defines values for ConnectionEndpointK8sServiceType.
const (
	ConnectionEndpointK8sServiceTypeCLUSTERIP    ConnectionEndpointK8sServiceType = "CLUSTERIP"
	ConnectionEndpointK8sServiceTypeLOADBALANCER ConnectionEndpointK8sServiceType = "LOADBALANCER"
	ConnectionEndpointK8sServiceTypeNODEPORT     ConnectionEndpointK8sServiceType = "NODEPORT"
)

// Defines values for DatacenterK8sServiceType.
const (
	DatacenterK8sServiceTypeLOADBALANCER DatacenterK8sServiceType = "LOADBALANCER"
	DatacenterK8sServiceTypeNODEPORT     DatacenterK8sServiceType = "NODEPORT"
)

// Defines values for EventBrokerServiceVersionDetailsReleaseStatus.
const (
	REVOKED EventBrokerServiceVersionDetailsReleaseStatus = "REVOKED"
)

// Defines values for MsgVpnAuthenticationBasicType.
const (
	INTERNAL MsgVpnAuthenticationBasicType = "INTERNAL"
	LDAP     MsgVpnAuthenticationBasicType = "LDAP"
	NONE     MsgVpnAuthenticationBasicType = "NONE"
	RADIUS   MsgVpnAuthenticationBasicType = "RADIUS"
)

// Defines values for OperationOperationType.
const (
	OperationOperationTypeCloneService          OperationOperationType = "cloneService"
	OperationOperationTypeCreateClientProfile   OperationOperationType = "createClientProfile"
	OperationOperationTypeCreateService         OperationOperationType = "createService"
	OperationOperationTypeDatacenterRequest     OperationOperationType = "datacenterRequest"
	OperationOperationTypeDeleteCertificate     OperationOperationType = "deleteCertificate"
	OperationOperationTypeDeleteClientProfile   OperationOperationType = "deleteClientProfile"
	OperationOperationTypeDeleteService         OperationOperationType = "deleteService"
	OperationOperationTypeInfrastructureRequest OperationOperationType = "infrastructureRequest"
	OperationOperationTypeInstallCertificate    OperationOperationType = "installCertificate"
	OperationOperationTypeServiceRequest        OperationOperationType = "serviceRequest"
	OperationOperationTypeUpdateClientProfile   OperationOperationType = "updateClientProfile"
	OperationOperationTypeUploadCertificate     OperationOperationType = "uploadCertificate"
)

// Defines values for OperationStatus.
const (
	OperationStatusFAILED     OperationStatus = "FAILED"
	OperationStatusINPROGRESS OperationStatus = "INPROGRESS"
	OperationStatusPENDING    OperationStatus = "PENDING"
	OperationStatusSUCCEEDED  OperationStatus = "SUCCEEDED"
)

// Defines values for ReleaseChannel.
const (
	DECLINED      ReleaseChannel = "DECLINED"
	PREVIEW       ReleaseChannel = "PREVIEW"
	PRODUCTION    ReleaseChannel = "PRODUCTION"
	PRODUCTIONLTS ReleaseChannel = "PRODUCTION_LTS"
)

// Defines values for ServiceAdminState.
const (
	DESTROY ServiceAdminState = "DESTROY"
	INITIAL ServiceAdminState = "INITIAL"
	START   ServiceAdminState = "START"
	STOP    ServiceAdminState = "STOP"
)

// Defines values for ServiceClassId.
const (
	ServiceClassIdDEVELOPER                      ServiceClassId = "DEVELOPER"
	ServiceClassIdENTERPRISE100KHIGHAVAILABILITY ServiceClassId = "ENTERPRISE_100K_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE100KSTANDALONE       ServiceClassId = "ENTERPRISE_100K_STANDALONE"
	ServiceClassIdENTERPRISE10KHIGHAVAILABILITY  ServiceClassId = "ENTERPRISE_10K_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE10KSTANDALONE        ServiceClassId = "ENTERPRISE_10K_STANDALONE"
	ServiceClassIdENTERPRISE1KHIGHAVAILABILITY   ServiceClassId = "ENTERPRISE_1K_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE1KSTANDALONE         ServiceClassId = "ENTERPRISE_1K_STANDALONE"
	ServiceClassIdENTERPRISE250HIGHAVAILABILITY  ServiceClassId = "ENTERPRISE_250_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE250STANDALONE        ServiceClassId = "ENTERPRISE_250_STANDALONE"
	ServiceClassIdENTERPRISE50KHIGHAVAILABILITY  ServiceClassId = "ENTERPRISE_50K_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE50KSTANDALONE        ServiceClassId = "ENTERPRISE_50K_STANDALONE"
	ServiceClassIdENTERPRISE5KHIGHAVAILABILITY   ServiceClassId = "ENTERPRISE_5K_HIGHAVAILABILITY"
	ServiceClassIdENTERPRISE5KSTANDALONE         ServiceClassId = "ENTERPRISE_5K_STANDALONE"
)

// Defines values for ServiceCloneAttributesComponents.
const (
	BROKERCONFIGURATION    ServiceCloneAttributesComponents = "BROKER_CONFIGURATION"
	CERTIFICATEAUTHORITIES ServiceCloneAttributesComponents = "CERTIFICATE_AUTHORITIES"
	SERVICECONFIGURATION   ServiceCloneAttributesComponents = "SERVICE_CONFIGURATION"
)

// Defines values for ServiceConnectionEndpointPortProtocol.
const (
	ManagementSshTlsListenPort             ServiceConnectionEndpointPortProtocol = "managementSshTlsListenPort"
	ServiceAmqpPlainTextListenPort         ServiceConnectionEndpointPortProtocol = "serviceAmqpPlainTextListenPort"
	ServiceAmqpTlsListenPort               ServiceConnectionEndpointPortProtocol = "serviceAmqpTlsListenPort"
	ServiceManagementTlsListenPort         ServiceConnectionEndpointPortProtocol = "serviceManagementTlsListenPort"
	ServiceMqttPlainTextListenPort         ServiceConnectionEndpointPortProtocol = "serviceMqttPlainTextListenPort"
	ServiceMqttTlsListenPort               ServiceConnectionEndpointPortProtocol = "serviceMqttTlsListenPort"
	ServiceMqttTlsWebSocketListenPort      ServiceConnectionEndpointPortProtocol = "serviceMqttTlsWebSocketListenPort"
	ServiceMqttWebSocketListenPort         ServiceConnectionEndpointPortProtocol = "serviceMqttWebSocketListenPort"
	ServiceRestIncomingPlainTextListenPort ServiceConnectionEndpointPortProtocol = "serviceRestIncomingPlainTextListenPort"
	ServiceRestIncomingTlsListenPort       ServiceConnectionEndpointPortProtocol = "serviceRestIncomingTlsListenPort"
	ServiceSmfCompressedListenPort         ServiceConnectionEndpointPortProtocol = "serviceSmfCompressedListenPort"
	ServiceSmfPlainTextListenPort          ServiceConnectionEndpointPortProtocol = "serviceSmfPlainTextListenPort"
	ServiceSmfTlsListenPort                ServiceConnectionEndpointPortProtocol = "serviceSmfTlsListenPort"
	ServiceWebPlainTextListenPort          ServiceConnectionEndpointPortProtocol = "serviceWebPlainTextListenPort"
	ServiceWebTlsListenPort                ServiceConnectionEndpointPortProtocol = "serviceWebTlsListenPort"
)

// Defines values for ServiceCreationState.
const (
	ServiceCreationStateCOMPLETED  ServiceCreationState = "COMPLETED"
	ServiceCreationStateFAILED     ServiceCreationState = "FAILED"
	ServiceCreationStateINPROGRESS ServiceCreationState = "INPROGRESS"
	ServiceCreationStatePENDING    ServiceCreationState = "PENDING"
)

// Defines values for GetDatacentersParamsDatacenterType.
const (
	CustomerCloud   GetDatacentersParamsDatacenterType = "CustomerCloud"
	CustomerOnPrem  GetDatacentersParamsDatacenterType = "CustomerOnPrem"
	SolaceDedicated GetDatacentersParamsDatacenterType = "SolaceDedicated"
	SolacePublic    GetDatacentersParamsDatacenterType = "SolacePublic"
	Unknown         GetDatacentersParamsDatacenterType = "Unknown"
)

// Defines values for GetDatacentersParamsProvider.
const (
	Aks   GetDatacentersParamsProvider = "aks"
	Aws   GetDatacentersParamsProvider = "aws"
	Azure GetDatacentersParamsProvider = "azure"
	Eks   GetDatacentersParamsProvider = "eks"
	Gcp   GetDatacentersParamsProvider = "gcp"
	K8s   GetDatacentersParamsProvider = "k8s"
)

// Defines values for GetServiceParamsExpand.
const (
	GetServiceParamsExpandAllowedActions             GetServiceParamsExpand = "allowedActions"
	GetServiceParamsExpandBroker                     GetServiceParamsExpand = "broker"
	GetServiceParamsExpandMessageSpoolDetails        GetServiceParamsExpand = "messageSpoolDetails"
	GetServiceParamsExpandServiceConnectionEndpoints GetServiceParamsExpand = "serviceConnectionEndpoints"
)

// Defines values for GetServiceClassParamsId.
const (
	GetServiceClassParamsIdDEVELOPER                      GetServiceClassParamsId = "DEVELOPER"
	GetServiceClassParamsIdENTERPRISE100KHIGHAVAILABILITY GetServiceClassParamsId = "ENTERPRISE_100K_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE100KSTANDALONE       GetServiceClassParamsId = "ENTERPRISE_100K_STANDALONE"
	GetServiceClassParamsIdENTERPRISE10KHIGHAVAILABILITY  GetServiceClassParamsId = "ENTERPRISE_10K_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE10KSTANDALONE        GetServiceClassParamsId = "ENTERPRISE_10K_STANDALONE"
	GetServiceClassParamsIdENTERPRISE1KHIGHAVAILABILITY   GetServiceClassParamsId = "ENTERPRISE_1K_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE1KSTANDALONE         GetServiceClassParamsId = "ENTERPRISE_1K_STANDALONE"
	GetServiceClassParamsIdENTERPRISE250HIGHAVAILABILITY  GetServiceClassParamsId = "ENTERPRISE_250_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE250STANDALONE        GetServiceClassParamsId = "ENTERPRISE_250_STANDALONE"
	GetServiceClassParamsIdENTERPRISE50KHIGHAVAILABILITY  GetServiceClassParamsId = "ENTERPRISE_50K_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE50KSTANDALONE        GetServiceClassParamsId = "ENTERPRISE_50K_STANDALONE"
	GetServiceClassParamsIdENTERPRISE5KHIGHAVAILABILITY   GetServiceClassParamsId = "ENTERPRISE_5K_HIGHAVAILABILITY"
	GetServiceClassParamsIdENTERPRISE5KSTANDALONE         GetServiceClassParamsId = "ENTERPRISE_5K_STANDALONE"
)

// BasicAuthAvailability defines model for BasicAuthAvailability.
type BasicAuthAvailability struct {
	// Enabled Select a value in the field to indicate whether basic authentication should be enabled or disabled for the event broker service. The valid values are:
	// <ul>
	//   <li><code>true</code>-enables basic authentication</li>
	//   <li><code>false</code>-disables basic authentication</li>
	// </ul>
	Enabled bool `json:"enabled"`
}

// BasicAuthAvailabilityResponse defines model for BasicAuthAvailabilityResponse.
type BasicAuthAvailabilityResponse struct {
	Data BasicAuthAvailability             `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// Broker Broker Details available on expand only.
type Broker struct {
	// ClientCertificateAuthorities The list of client certificate authorities.
	ClientCertificateAuthorities *[]CertificateAuthority `json:"clientCertificateAuthorities,omitempty"`

	// Cluster The DMR cluster details.
	Cluster *Cluster `json:"cluster,omitempty"`

	// ConfigSyncSslEnabled Enable or disable Config-Sync encryption (SSL). The default value is true, and the valid values are: <p><ul><li>'true' - enabled</li><li>'false' - disabled</li></ul></p>
	ConfigSyncSslEnabled *bool `json:"configSyncSslEnabled,omitempty"`

	// DiskSize The disk size for the message spool, in gigabytes (GB).
	DiskSize *int32 `json:"diskSize,omitempty"`

	// DomainCertificateAuthorities The list of domain certificate authorities.
	DomainCertificateAuthorities *[]CertificateAuthority `json:"domainCertificateAuthorities,omitempty"`

	// LdapProfiles The LDAP profiles configured for the event broker service.
	LdapProfiles *[]LdapProfile `json:"ldapProfiles,omitempty"`

	// ManagementReadOnlyLoginCredential The mission control manager login credentials
	ManagementReadOnlyLoginCredential *ManagementLoginCredential `json:"managementReadOnlyLoginCredential,omitempty"`

	// MaxSpoolUsage The maximum message spool usage allowed on the event broker service, in gigabytes (GB).
	MaxSpoolUsage *int32 `json:"maxSpoolUsage,omitempty"`

	// MonitoringMode The monitoring mode. This can be 'BASIC' or 'ADVANCED'. The value of BASIC is default monitoring and ADVANCED means that monitoring of the event broker is enabled.
	MonitoringMode *BrokerMonitoringMode `json:"monitoringMode,omitempty"`

	// MsgVpns The list of Message VPNs configured on the event broker service.
	MsgVpns *[]MsgVpn `json:"msgVpns,omitempty"`

	// RedundancyGroupSslEnabled Enable or disable SSL for the redundancy group (for mate-link encryption).  The default value is false and the valid values are: <p><ul><li>'true' - enabled</li><li>'false' - disabled</li></ul></p>
	RedundancyGroupSslEnabled *bool `json:"redundancyGroupSslEnabled,omitempty"`

	// TlsStandardDomainCertificateAuthoritiesEnabled Indicates whether TLS Standard Domain Certificate Authorities is enabled.
	TlsStandardDomainCertificateAuthoritiesEnabled *bool `json:"tlsStandardDomainCertificateAuthoritiesEnabled,omitempty"`

	// Version The version number for the event broker service.
	Version *string `json:"version,omitempty"`

	// VersionFamily Version Family, a truncated form of the version.
	VersionFamily *string `json:"versionFamily,omitempty"`
}

// BrokerMonitoringMode The monitoring mode. This can be 'BASIC' or 'ADVANCED'. The value of BASIC is default monitoring and ADVANCED means that monitoring of the event broker is enabled.
type BrokerMonitoringMode string

// BrokerSempProxyError The error response of the broker SEMP proxy request.
type BrokerSempProxyError struct {
	// Meta The metadata of the broker SEMP proxy request error.
	Meta *BrokerSempProxyErrorMeta `json:"meta,omitempty"`
}

// BrokerSempProxyErrorMeta The metadata of the broker SEMP proxy request error.
type BrokerSempProxyErrorMeta struct {
	Error        *SempError   `json:"error,omitempty"`
	Request      *SempRequest `json:"request,omitempty"`
	ResponseCode *int32       `json:"responseCode,omitempty"`
}

// CertificateAuthority The certificate authority.
type CertificateAuthority struct {
	// Name Name
	Name *string `json:"name,omitempty"`
}

// CertificateType The certificate type.
type CertificateType string

// ClientProfile The client profile configured on the event broker service.
type ClientProfile struct {
	// AllowBridgeConnectionsEnabled Indicates whether clients assigned to the client profile are allowed to establish Dynamic Messaging Routing (DMR) links (or bridge links) from the current Message VPN to another Message VPN in a separate event broker service. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowBridgeConnectionsEnabled *bool `json:"allowBridgeConnectionsEnabled,omitempty"`

	// AllowGuaranteedEndpointCreateEnabled Indicates whether clients assigned to the client profile are allowed to create queues or topic endpoints. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowGuaranteedEndpointCreateEnabled *bool `json:"allowGuaranteedEndpointCreateEnabled,omitempty"`

	// AllowGuaranteedMsgReceiveEnabled Indicates whether clients assigned to the client profile are allowed to bind to topic endpoints or queues to receive guaranteed messages. The valid values are 'true' (allowed) or 'false' (not allowed). The default is 'false'.
	AllowGuaranteedMsgReceiveEnabled *bool `json:"allowGuaranteedMsgReceiveEnabled,omitempty"`

	// AllowGuaranteedMsgSendEnabled Indicates whether clients assigned to the client profile are allowed to publish guaranteed messages. The valid values are 'true' (allowed) or 'false' (not allowed) . The default is 'false'.
	AllowGuaranteedMsgSendEnabled *bool `json:"allowGuaranteedMsgSendEnabled,omitempty"`

	// AllowSharedSubscriptionsEnabled Indicates whether clients assigned to the client profile are allowed to use shared subscriptions. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowSharedSubscriptionsEnabled *bool `json:"allowSharedSubscriptionsEnabled,omitempty"`

	// AllowTransactedSessionsEnabled Indicates whether client applications client applications assigned to the client profile are allowed to establish transacted sessions or XA sessions. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowTransactedSessionsEnabled *bool `json:"allowTransactedSessionsEnabled,omitempty"`

	// ApiQueueManagementCopyFromOnCreateName <p><em>Removal Date: 2024-05-26</em></p><p><em>Reason: Replaced by apiQueueManagementCopyFromOnCreateTemplateName</em></p><p>The name of a queue template to copy settings from when a new queue is created by the client using the client profile. If the specified queue template does not exist, creation fails. Deprecated since 2.14. This attribute has been replaced with apiQueueManagementCopyFromOnCreateTemplateName.</p>
	// Deprecated:
	ApiQueueManagementCopyFromOnCreateName *string `json:"apiQueueManagementCopyFromOnCreateName,omitempty"`

	// ApiQueueManagementCopyFromOnCreateTemplateName The name of a queue template to copy settings from when a new queue is created by the client using the client profile. If the specified queue template does not exist, creation fails.
	ApiQueueManagementCopyFromOnCreateTemplateName *string `json:"apiQueueManagementCopyFromOnCreateTemplateName,omitempty"`

	// ApiTopicEndpointManagementCopyFromOnCreateName <p><em>Removal Date: 2024-05-26</em></p><p><em>Reason: Replaced by apiTopicEndpointManagementCopyFromOnCreateTemplateName</em></p><p>The name of a topic endpoint to copy settings from when a new topic endpoint is created by the client using the client profile. If the specified topic endpoint does not exist, creation fails. Deprecated since 2.14. This attribute has been replaced with apiTopicEndpointManagementCopyFromOnCreateTemplateName.</p>
	// Deprecated:
	ApiTopicEndpointManagementCopyFromOnCreateName *string `json:"apiTopicEndpointManagementCopyFromOnCreateName,omitempty"`

	// ApiTopicEndpointManagementCopyFromOnCreateTemplateName The name of a topic endpoint to copy settings from when a new topic endpoint is created by the client using the client profile. If the specified topic endpoint does not exist, creation fails.
	ApiTopicEndpointManagementCopyFromOnCreateTemplateName *string `json:"apiTopicEndpointManagementCopyFromOnCreateTemplateName,omitempty"`

	// CompressionEnabled Indicates whether clients assigned to the client profile are allowed to transfer data using compression. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'true'.
	CompressionEnabled *bool `json:"compressionEnabled,omitempty"`

	// ElidingDelay The amount of time to delay the delivery of messages to a client after the initial message has been delivered. You can specify a value from 0-6000 milliseconds. The default is 0.
	ElidingDelay *int32 `json:"elidingDelay,omitempty"`

	// ElidingEnabled Indicates whether clients assigned to the client profile are allowed to use eliding. Eliding allows clients to define a custom per-topic rate for client applications so they can effectively consume relevant messages, rather than queuing up outdated messages. For example, when eliding is configured, clients could receive direct messages for their topic subscriptions at a rate of at most five per second, per topic–even though the source is publishing updates at a much higher rate. The valid values are 'true' (enabled) and 'false' (not enabled). The default is 'false'.
	ElidingEnabled *bool `json:"elidingEnabled,omitempty"`

	// ElidingMaxTopicCount The maximum number of topics the event broker service that can track for performing the eliding function on each client connection. You can specify a value from 1-320000. The default is 256.
	ElidingMaxTopicCount *int32 `json:"elidingMaxTopicCount,omitempty"`

	// EventClientProvisionedEndpointSpoolUsageThreshold The clear ('clearPercent') and raise ('setPercent') threshold values that determine when to generate events for the percentage amount of the message spool used by all endpoints provisioned by clients for the given client profile.
	EventClientProvisionedEndpointSpoolUsageThreshold *ProvisionedEndpointSpoolUsageAlertThresholds `json:"eventClientProvisionedEndpointSpoolUsageThreshold,omitempty"`

	// Id The identifier of the client profile.
	Id *string `json:"id,omitempty"`

	// MaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Web transport client connections to the event broker service that can be made using the same client username account. The default is the maximum value supported by the platform.
	MaxConnectionCountPerClientUsername *int32 `json:"maxConnectionCountPerClientUsername,omitempty"`

	// MaxEgressFlowCount The maximum number of egress flows (that is, Guaranteed Message client receive flows or consumer flows) that can be created by a single client associated with this client profile. The default is 1000.
	MaxEgressFlowCount *int32 `json:"maxEgressFlowCount,omitempty"`

	// MaxEndpointCountPerClientUsername The maximum number of durable and non-durable queues and topic endpoints that can be owned by the clients using the same client username within a client profile. The default is 1000.
	MaxEndpointCountPerClientUsername *int32 `json:"maxEndpointCountPerClientUsername,omitempty"`

	// MaxIngressFlowCount The maximum number of ingress flows (that is, Guaranteed Message client publish flows) that can be created by a single client associated with this client profile. The default is 1000.
	MaxIngressFlowCount *int32 `json:"maxIngressFlowCount,omitempty"`

	// MaxSubscriptionCount The maximum number of subscriptions for a single client in the client profile. When you set this option, consider the total maximum number of permitted topic subscriptions and the total maximum number of client connections for the type of event broker that is used. That is, to ensure reliable system performance, you must find the right balance for your network, while staying within the system limits mentioned. The balance is generally between allowing the creation of many client applications and allowing each client to add a large number of topic subscriptions. The default varies by platform.
	MaxSubscriptionCount *int32 `json:"maxSubscriptionCount,omitempty"`

	// MaxTransactedSessionCount The maximum number of simultaneous transacted sessions and/or XA sessions allowed for a single client associated with the client profile. The default is 10.
	MaxTransactedSessionCount *int32 `json:"maxTransactedSessionCount,omitempty"`

	// MaxTransactionCount The total maximum number of simultaneous transactions (both local transactions and transactions within the XA transaction branches) allowed for a single client associated with the client profile. The default varies by platform.
	MaxTransactionCount *int32 `json:"maxTransactionCount,omitempty"`

	// Name The name of the client profile.
	Name string `json:"name"`

	// QueueControl1MaxDepth The egress queue maximum depth for Control 1 that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueControl1MaxDepth *int32 `json:"queueControl1MaxDepth,omitempty"`

	// QueueControl1MinMsgBurst The minimum number of messages that must be on the Direct 1 (COS 1) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueControl1MinMsgBurst *int32 `json:"queueControl1MinMsgBurst,omitempty"`

	// QueueDirect1MaxDepth The egress queue maximum depth for Direct Messages 1 [Class of Service (COS) 1] that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000..
	QueueDirect1MaxDepth *int32 `json:"queueDirect1MaxDepth,omitempty"`

	// QueueDirect1MinMsgBurst The minimum number of messages that must be on the Direct 1 (COS 1) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect1MinMsgBurst *int32 `json:"queueDirect1MinMsgBurst,omitempty"`

	// QueueDirect2MaxDepth The egress queue maximum depth for Direct Messages 2 (COS 2) that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueDirect2MaxDepth *int32 `json:"queueDirect2MaxDepth,omitempty"`

	// QueueDirect2MinMsgBurst The minimum number of messages that must be on the Direct 2 (COS 2) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect2MinMsgBurst *int32 `json:"queueDirect2MinMsgBurst,omitempty"`

	// QueueDirect3MaxDepth The egress queue maximum depth for Direct Messages 3 [Class of Service (COS) 3] that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueDirect3MaxDepth *int32 `json:"queueDirect3MaxDepth,omitempty"`

	// QueueDirect3MinMsgBurst The minimum number of messages that must be on the Direct 3 (COS 3) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect3MinMsgBurst *int32 `json:"queueDirect3MinMsgBurst,omitempty"`

	// QueueGuaranteed1MaxDepth The egress queue maximum depth for Guaranteed Messages that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueGuaranteed1MaxDepth *int32 `json:"queueGuaranteed1MaxDepth,omitempty"`

	// QueueGuaranteed1MinMsgBurst The minimum number of messages that must be on the Guaranteed Message queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 255. The value of 255 is recommended for memory usage optimized configurations, such as message applications; a value of 66000 is for WAN optimized configurations.
	QueueGuaranteed1MinMsgBurst *int32 `json:"queueGuaranteed1MinMsgBurst,omitempty"`

	// RejectMsgToSenderOnNoSubscriptionMatchEnabled Indicates whether clients assigned the client profile are allowed to return NACKs (negative acknowledgements) for guaranteed messages that do not have a that do not have a matching guaranteed message subscription. The value values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	RejectMsgToSenderOnNoSubscriptionMatchEnabled *bool `json:"rejectMsgToSenderOnNoSubscriptionMatchEnabled,omitempty"`

	// ReplicationAllowClientConnectWhenStandbyEnabled Indicates whether clients assigned to the client profile are allowed to remain connected to the Message VPN when its replication state is Standby. This situation may occur when the Message VPN Replication state of the event broker service changes from Active to Standby. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	ReplicationAllowClientConnectWhenStandbyEnabled *bool `json:"replicationAllowClientConnectWhenStandbyEnabled,omitempty"`

	// ServiceMinKeepaliveTimeout The minimum period of time (in seconds) that the event broker service will tolerate inactivity on the client connection. This keepalive value is also enforced for MQTT and SMF (Solace Message Format) connections. The keepalive timeout value is calculated based on the client provided timeout interval (3 x the keepalive interval for SMF, 1.5 x the keepalive interval for MQTT). The default is 30 and valid ranges are 3–3600.
	ServiceMinKeepaliveTimeout *int32 `json:"serviceMinKeepaliveTimeout,omitempty"`

	// ServiceSmfMaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Solace Message Format (SMF) client connections to the event broker that can be made using the same client username account. The default is the maximum value supported by the platform.
	ServiceSmfMaxConnectionCountPerClientUsername *int32 `json:"serviceSmfMaxConnectionCountPerClientUsername,omitempty"`

	// ServiceSmfMinKeepaliveEnabled Indicates whether clients using the client profile have the minimum keep-alive timeout enabled for SMF (Solace Message Format) connections. The valid values are 'true' (enabled) and 'false' (not enabled). The default is 'false'.
	ServiceSmfMinKeepaliveEnabled *bool `json:"serviceSmfMinKeepaliveEnabled,omitempty"`

	// ServiceWebInactiveTimeout The number of seconds a Web client has to send a request before its session times out and be terminated for being inactive. The default value is 30 seconds.
	ServiceWebInactiveTimeout *int32 `json:"serviceWebInactiveTimeout,omitempty"`

	// ServiceWebMaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Web transport client connections to the event broker service that can be made using the same client username account. The default is the maximum value supported by the platform.
	ServiceWebMaxConnectionCountPerClientUsername *int32 `json:"serviceWebMaxConnectionCountPerClientUsername,omitempty"`

	// ServiceWebMaxPayload The maximum transport payload size (in bytes) before fragmentation occurs for clients using the client profile. The size of the header is not included.
	//
	// Solace Message Format (SMF) messages that are sent to a consuming Web client are contained within a Web transport message that the event broker sends in its HTTP response to that client. Each Web transport message that is sent can contain multiple SMF messages or partial SMF messages.
	// The maximum Web payload value sets the maximum number of bytes allowed in a single Web transport message (not including the header). This value determines the number of SMF messages that can be sent in a single HTTP response and the size of the Web transport message sent in the HTTP response. The value range is 300 to 10000000, in bytes. The default is 1000000 bytes.
	//
	// SMF messages that are sent to a consuming Web client are contained within a Web transport message that the event broker sends in its HTTP response to that client. Each Web transport message that is sent can contain multiple SMF messages or partial SMF messages.
	//
	// The maximum Web payload value sets the maximum number of bytes allowed in a single Web transport message (not including the header). This value determines the number of SMF messages that can be sent in a single HTTP response and the size of the Web transport message sent in the HTTP response. Note that large SMF messages can be fragmented across Web transport messages to respect the value set for the maximum possible Web payload.
	// )
	ServiceWebMaxPayload *int32 `json:"serviceWebMaxPayload,omitempty"`

	// TcpCongestionWindowSize The TCP initial congestion window size is the number of segments that TCP sends before waiting for an acknowledgment from the peer. The TCP initial congestion window size is used when starting up a TCP connection or on recovery from idle (that is, no traffic). Larger values of the initial window allows a connection to come up to speed more quickly. For further details, refer to RFC 2581.
	// Changing the TCP initial congestion window size from its default of 2 results in non-compliance with RFC 2581. Further, if this setting is set to a value too high, it may cause congestion in the network. Contact support before you attempt to change this TCP parameter.
	TcpCongestionWindowSize *int32 `json:"tcpCongestionWindowSize,omitempty"`

	// TcpKeepaliveCount The maximum number of keepalive probes (from 2 to 5 ) that TCP should send before dropping the connection. The default is 5.
	TcpKeepaliveCount *int32 `json:"tcpKeepaliveCount,omitempty"`

	// TcpKeepaliveIdleTime The time (from 3 to 120 seconds) a connection must remain idle before TCP begins sending keepalive probes. The default is 3.
	TcpKeepaliveIdleTime *int32 `json:"tcpKeepaliveIdleTime,omitempty"`

	// TcpKeepaliveInterval The time (from 1 to 30 seconds) to set as the interval between individual keepalive probes. The default is 1.
	TcpKeepaliveInterval *int32 `json:"tcpKeepaliveInterval,omitempty"`

	// TcpMaxSegmentSize The TCP maximum segment size (MSS) used for client to the event broker service. The default is 1460.
	TcpMaxSegmentSize *int32 `json:"tcpMaxSegmentSize,omitempty"`

	// TcpMaxWindowSize The TCP window size between the event broker service and the client.
	// If the maximum window size is set to less than the bandwidth-delay product, then the TCP connection operates below its maximum potential throughput. If the maximum window is set to less than about twice the bandwidth-delay product, then occasional packet loss causes the TCP connection to operate below its maximum potential throughput as it handles the missing acknowledgments and retransmissions. The default is 256.
	//
	// Alternately, if the TCP maximum window size is set too large, in the presence of a high offered load, TCP gradually increases its congestion window size until either the congestion window size reaches the maximum window size, or packet loss occurs in the network.
	//
	// Initially, when the TCP congestion window size is small, the physical bandwidth-delay of the network acts as a memory buffer for packets in flight. But as the congestion window crosses the bandwidth-delay product, the buffering of in-flight packets moves to queues in event broker services and other equipment throughout the network. As the TCP congestion window continues to increase in size, these various equipment queues overflow, causing packet loss and TCP backoff.
	TcpMaxWindowSize *int32 `json:"tcpMaxWindowSize,omitempty"`

	// TlsAllowDowngradeToPlainTextEnabled Indicates whether clients assigned the client profile are allowed to use TLS/SSL encryption to protect the clients' credentials. This setting doesn't encrypt the data that is transmitted after the clients are authenticated and authorized. This also allows connecting client applications to request to downgrade of their TLS/SSL connections to the Message VPN to a plain-text connection, and if that Message VPN allows TLS/SSL connection downgrades, after the clientsʼ login handshake are finished, their connections are downgraded. This means that the clientsʼ authentication data is still encrypted, but the subsequent application data that is transmitted is sent as non-encrypted plain-text. The valid values are 'true (allowed) or 'false (not allowed). The default is 'true'.
	TlsAllowDowngradeToPlainTextEnabled *bool `json:"tlsAllowDowngradeToPlainTextEnabled,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// ClientProfileBase The client profile configured on the event broker service.
type ClientProfileBase struct {
	// Name The name of the client profile.
	Name string `json:"name"`
}

// ClientProfileRequest The client profile configured on the event broker service.
type ClientProfileRequest struct {
	// AllowBridgeConnectionsEnabled Indicates whether clients assigned to the client profile are allowed to establish Dynamic Messaging Routing (DMR) links (or bridge links) from the current Message VPN to another Message VPN in a separate event broker service. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowBridgeConnectionsEnabled *bool `json:"allowBridgeConnectionsEnabled,omitempty"`

	// AllowGuaranteedEndpointCreateEnabled Indicates whether clients assigned to the client profile are allowed to create queues or topic endpoints. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowGuaranteedEndpointCreateEnabled *bool `json:"allowGuaranteedEndpointCreateEnabled,omitempty"`

	// AllowGuaranteedMsgReceiveEnabled Indicates whether clients assigned to the client profile are allowed to bind to topic endpoints or queues to receive guaranteed messages. The valid values are 'true' (allowed) or 'false' (not allowed). The default is 'false'.
	AllowGuaranteedMsgReceiveEnabled *bool `json:"allowGuaranteedMsgReceiveEnabled,omitempty"`

	// AllowGuaranteedMsgSendEnabled Indicates whether clients assigned to the client profile are allowed to publish guaranteed messages. The valid values are 'true' (allowed) or 'false' (not allowed) . The default is 'false'.
	AllowGuaranteedMsgSendEnabled *bool `json:"allowGuaranteedMsgSendEnabled,omitempty"`

	// AllowSharedSubscriptionsEnabled Indicates whether clients assigned to the client profile are allowed to use shared subscriptions. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowSharedSubscriptionsEnabled *bool `json:"allowSharedSubscriptionsEnabled,omitempty"`

	// AllowTransactedSessionsEnabled Indicates whether client applications client applications assigned to the client profile are allowed to establish transacted sessions or XA sessions. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowTransactedSessionsEnabled *bool `json:"allowTransactedSessionsEnabled,omitempty"`

	// ApiQueueManagementCopyFromOnCreateName <p><em>Removal Date: 2024-05-26</em></p><p><em>Reason: Replaced by apiQueueManagementCopyFromOnCreateTemplateName</em></p>The name of a queue template to copy settings from when a new queue is <p>created by the client using the client profile. If the specified queue template does not exist, creation fails. Deprecated since 2.14. This attribute has been replaced with apiQueueManagementCopyFromOnCreateTemplateName.</p>
	// Deprecated:
	ApiQueueManagementCopyFromOnCreateName *string `json:"apiQueueManagementCopyFromOnCreateName,omitempty"`

	// ApiQueueManagementCopyFromOnCreateTemplateName The name of a queue template to copy settings from when a new queue is created by the client using the client profile. If the specified queue template does not exist, creation fails.
	ApiQueueManagementCopyFromOnCreateTemplateName *string `json:"apiQueueManagementCopyFromOnCreateTemplateName,omitempty"`

	// ApiTopicEndpointManagementCopyFromOnCreateName <p><em>Removal Date: 2024-05-26</em></p><p><em>Reason: Replaced by apiTopicEndpointManagementCopyFromOnCreateTemplateName</em></p><p>The name of a topic endpoint to copy settings from when a new topic endpoint is created by the client using the client profile. If the specified topic endpoint does not exist, creation fails. Deprecated since 2.14. This attribute has been replaced with apiTopicEndpointManagementCopyFromOnCreateTemplateName.</p>
	// Deprecated:
	ApiTopicEndpointManagementCopyFromOnCreateName *string `json:"apiTopicEndpointManagementCopyFromOnCreateName,omitempty"`

	// ApiTopicEndpointManagementCopyFromOnCreateTemplateName The name of a topic endpoint to copy settings from when a new topic endpoint is created by the client using the client profile. If the specified topic endpoint does not exist, creation fails.
	ApiTopicEndpointManagementCopyFromOnCreateTemplateName *string `json:"apiTopicEndpointManagementCopyFromOnCreateTemplateName,omitempty"`

	// CompressionEnabled Indicates whether clients assigned to the client profile are allowed to transfer data using compression. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'true'.
	CompressionEnabled *bool `json:"compressionEnabled,omitempty"`

	// ElidingDelay The amount of time to delay the delivery of messages to a client after the initial message has been delivered. You can specify a value from 0-6000 milliseconds. The default is 0.
	ElidingDelay *int32 `json:"elidingDelay,omitempty"`

	// ElidingEnabled Indicates whether clients assigned to the client profile are allowed to use eliding. Eliding allows clients to define a custom per-topic rate for client applications so they can effectively consume relevant messages, rather than queuing up outdated messages. For example, when eliding is configured, clients could receive direct messages for their topic subscriptions at a rate of at most five per second, per topic–even though the source is publishing updates at a much higher rate. The valid values are 'true' (enabled) and 'false' (not enabled). The default is 'false'.
	ElidingEnabled *bool `json:"elidingEnabled,omitempty"`

	// ElidingMaxTopicCount The maximum number of topics the event broker service that can track for performing the eliding function on each client connection. You can specify a value from 1-320000. The default is 256.
	ElidingMaxTopicCount *int32 `json:"elidingMaxTopicCount,omitempty"`

	// EventClientProvisionedEndpointSpoolUsageThreshold The clear ('clearPercent') and raise ('setPercent') threshold values that determine when to generate events for the percentage amount of the message spool used by all endpoints provisioned by clients for the given client profile.
	EventClientProvisionedEndpointSpoolUsageThreshold *ProvisionedEndpointSpoolUsageAlertThresholds `json:"eventClientProvisionedEndpointSpoolUsageThreshold,omitempty"`
	Id                                                *string                                       `json:"id,omitempty"`

	// MaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Web transport client connections to the event broker service that can be made using the same client username account. The default is the maximum value supported by the platform.
	MaxConnectionCountPerClientUsername *int32 `json:"maxConnectionCountPerClientUsername,omitempty"`

	// MaxEgressFlowCount The maximum number of egress flows (that is, Guaranteed Message client receive flows or consumer flows) that can be created by a single client associated with this client profile. The default is 1000.
	MaxEgressFlowCount *int32 `json:"maxEgressFlowCount,omitempty"`

	// MaxEndpointCountPerClientUsername The maximum number of durable and non-durable queues and topic endpoints that can be owned by the clients using the same client username within a client profile. The default is 1000.
	MaxEndpointCountPerClientUsername *int32 `json:"maxEndpointCountPerClientUsername,omitempty"`

	// MaxIngressFlowCount The maximum number of ingress flows (that is, Guaranteed Message client publish flows) that can be created by a single client associated with this client profile. The default is 1000.
	MaxIngressFlowCount *int32 `json:"maxIngressFlowCount,omitempty"`

	// MaxSubscriptionCount The maximum number of subscriptions for a single client in the client profile. When you set this option, consider the total maximum number of permitted topic subscriptions and the total maximum number of client connections for the type of event broker that is used. That is, to ensure reliable system performance, you must find the right balance for your network, while staying within the system limits mentioned. The balance is generally between allowing the creation of many client applications and allowing each client to add a large number of topic subscriptions. The default varies by platform.
	MaxSubscriptionCount *int32 `json:"maxSubscriptionCount,omitempty"`

	// MaxTransactedSessionCount The maximum number of simultaneous transacted sessions and/or XA sessions allowed for a single client associated with the client profile. The default is 10.
	MaxTransactedSessionCount *int32 `json:"maxTransactedSessionCount,omitempty"`

	// MaxTransactionCount The total maximum number of simultaneous transactions (both local transactions and transactions within the XA transaction branches) allowed for a single client associated with the client profile. The default varies by platform.
	MaxTransactionCount *int32  `json:"maxTransactionCount,omitempty"`
	Name                *string `json:"name,omitempty"`

	// QueueControl1MaxDepth The egress queue maximum depth for Control 1 that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueControl1MaxDepth *int32 `json:"queueControl1MaxDepth,omitempty"`

	// QueueControl1MinMsgBurst The minimum number of messages that must be on the Direct 1 (COS 1) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueControl1MinMsgBurst *int32 `json:"queueControl1MinMsgBurst,omitempty"`

	// QueueDirect1MaxDepth The egress queue maximum depth for Direct Messages 1 [Class of Service (COS) 1] that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueDirect1MaxDepth *int32 `json:"queueDirect1MaxDepth,omitempty"`

	// QueueDirect1MinMsgBurst The minimum number of messages that must be on the Direct 1 (COS 1) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect1MinMsgBurst *int32 `json:"queueDirect1MinMsgBurst,omitempty"`

	// QueueDirect2MaxDepth The egress queue maximum depth for Direct Messages 2 (COS 2) that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueDirect2MaxDepth *int32 `json:"queueDirect2MaxDepth,omitempty"`

	// QueueDirect2MinMsgBurst The minimum number of messages that must be on the Direct 2 (COS 2) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect2MinMsgBurst *int32 `json:"queueDirect2MinMsgBurst,omitempty"`

	// QueueDirect3MaxDepth The egress queue maximum depth for Direct Messages 3 [Class of Service (COS) 3] that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueDirect3MaxDepth *int32 `json:"queueDirect3MaxDepth,omitempty"`

	// QueueDirect3MinMsgBurst The minimum number of messages that must be on the Direct 3 (COS 3) queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 4.
	QueueDirect3MinMsgBurst *int32 `json:"queueDirect3MinMsgBurst,omitempty"`

	// QueueGuaranteed1MaxDepth The egress queue maximum depth for Guaranteed Messages that represents the number of work units for the client priority queues. The valid range is 2 to 262144. The default is 20000.
	QueueGuaranteed1MaxDepth *int32 `json:"queueGuaranteed1MaxDepth,omitempty"`

	// QueueGuaranteed1MinMsgBurst The minimum number of messages that must be on the Guaranteed Message queue before the queue’s depth is checked against the maximum depth setting (thereby allowing the queue to absorb a burst of large messages that exceeds the number of allowed work units). A valid range is 0 to 262144 with the default of 255. The value of 255 is recommended for memory usage optimized configurations, such as message applications; a value of 66000 is for WAN optimized configurations.
	QueueGuaranteed1MinMsgBurst *int32 `json:"queueGuaranteed1MinMsgBurst,omitempty"`

	// RejectMsgToSenderOnNoSubscriptionMatchEnabled Indicates whether clients assigned the client profile are allowed to return NACKs (negative acknowledgements) for guaranteed messages that do not have a that do not have a matching guaranteed message subscription. The value values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	RejectMsgToSenderOnNoSubscriptionMatchEnabled *bool `json:"rejectMsgToSenderOnNoSubscriptionMatchEnabled,omitempty"`

	// ReplicationAllowClientConnectWhenStandbyEnabled Indicates whether clients assigned to the client profile are allowed to remain connected to the Message VPN when its replication state is Standby. This situation may occur when the Message VPN Replication state of the event broker service changes from Active to Standby. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	ReplicationAllowClientConnectWhenStandbyEnabled *bool `json:"replicationAllowClientConnectWhenStandbyEnabled,omitempty"`

	// ServiceMinKeepaliveTimeout The minimum period of time (in seconds) that the event broker service will tolerate inactivity on the client connection. This keepalive value is also enforced for MQTT and SMF (Solace Message Format) connections. The keepalive timeout value is calculated based on the client provided timeout interval (3 x the keepalive interval for SMF, 1.5 x the keepalive interval for MQTT). The default is 30 and valid ranges are 3–3600.
	ServiceMinKeepaliveTimeout *int32 `json:"serviceMinKeepaliveTimeout,omitempty"`

	// ServiceSmfMaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Solace Message Format (SMF) client connections to the event broker that can be made using the same client username account. The default is the maximum value supported by the platform.
	ServiceSmfMaxConnectionCountPerClientUsername *int32 `json:"serviceSmfMaxConnectionCountPerClientUsername,omitempty"`

	// ServiceSmfMinKeepaliveEnabled Indicates whether clients using the client profile have the minimum keep-alive timeout enabled for SMF (Solace Message Format) connections. The valid values are 'true' (enabled) and 'false' (not enabled). The default is 'false'.
	ServiceSmfMinKeepaliveEnabled *bool `json:"serviceSmfMinKeepaliveEnabled,omitempty"`

	// ServiceWebInactiveTimeout The number of seconds a Web client has to send a request before its session times out and be terminated for being inactive. The default value is 30 seconds.
	ServiceWebInactiveTimeout *int32 `json:"serviceWebInactiveTimeout,omitempty"`

	// ServiceWebMaxConnectionCountPerClientUsername The maximum permitted number of simultaneous Web transport client connections to the event broker service that can be made using the same client username account. The default is the maximum value supported by the platform.
	ServiceWebMaxConnectionCountPerClientUsername *int32 `json:"serviceWebMaxConnectionCountPerClientUsername,omitempty"`

	// ServiceWebMaxPayload The maximum transport payload size (in bytes) before fragmentation occurs for clients using the client profile. The size of the header is not included.
	//
	// Solace Message Format (SMF) messages that are sent to a consuming Web client are contained within a Web transport message that the event broker sends in its HTTP response to that client. Each Web transport message that is sent can contain multiple SMF messages or partial SMF messages.
	// The maximum Web payload value sets the maximum number of bytes allowed in a single Web transport message (not including the header). This value determines the number of SMF messages that can be sent in a single HTTP response and the size of the Web transport message sent in the HTTP response. The value range is 300 to 10000000, in bytes. The default is 1000000 bytes.
	//
	// SMF messages that are sent to a consuming Web client are contained within a Web transport message that the event broker sends in its HTTP response to that client. Each Web transport message that is sent can contain multiple SMF messages or partial SMF messages.
	//
	// The maximum Web payload value sets the maximum number of bytes allowed in a single Web transport message (not including the header). This value determines the number of SMF messages that can be sent in a single HTTP response and the size of the Web transport message sent in the HTTP response. Note that large SMF messages can be fragmented across Web transport messages to respect the value set for the maximum possible Web payload.
	ServiceWebMaxPayload *int32 `json:"serviceWebMaxPayload,omitempty"`

	// TcpCongestionWindowSize The TCP initial congestion window size is the number of segments that TCP sends before waiting for an acknowledgment from the peer. The TCP initial congestion window size is used when starting up a TCP connection or on recovery from idle (that is, no traffic). Larger values of the initial window allows a connection to come up to speed more quickly. For further details, refer to RFC 2581.
	// Changing the TCP initial congestion window size from its default of 2 results in non-compliance with RFC 2581. Further, if this setting is set to a value too high, it may cause congestion in the network. Contact support before you attempt to change this TCP parameter.
	TcpCongestionWindowSize *int32 `json:"tcpCongestionWindowSize,omitempty"`

	// TcpKeepaliveCount The maximum number of keepalive probes (from 2 to 5 ) that TCP should send before dropping the connection. The default is 5.
	TcpKeepaliveCount *int32 `json:"tcpKeepaliveCount,omitempty"`

	// TcpKeepaliveIdleTime The time (from 3 to 120 seconds) a connection must remain idle before TCP begins sending keepalive probes. The default is 3.
	TcpKeepaliveIdleTime *int32 `json:"tcpKeepaliveIdleTime,omitempty"`

	// TcpKeepaliveInterval The time (from 1 to 30 seconds) to set as the interval between individual keepalive probes. The default is 1.
	TcpKeepaliveInterval *int32 `json:"tcpKeepaliveInterval,omitempty"`

	// TcpMaxSegmentSize The TCP maximum segment size (MSS) used for client to the event broker service. The default is 1460.
	TcpMaxSegmentSize *int32 `json:"tcpMaxSegmentSize,omitempty"`

	// TcpMaxWindowSize The TCP window size between the event broker service and the client.
	// If the maximum window size is set to less than the bandwidth-delay product, then the TCP connection operates below its maximum potential throughput. If the maximum window is set to less than about twice the bandwidth-delay product, then occasional packet loss causes the TCP connection to operate below its maximum potential throughput as it handles the missing acknowledgments and retransmissions. The default is 256.
	//
	// Alternately, if the TCP maximum window size is set too large, in the presence of a high offered load, TCP gradually increases its congestion window size until either the congestion window size reaches the maximum window size, or packet loss occurs in the network.
	//
	// Initially, when the TCP congestion window size is small, the physical bandwidth-delay of the network acts as a memory buffer for packets in flight. But as the congestion window crosses the bandwidth-delay product, the buffering of in-flight packets moves to queues in event broker services and other equipment throughout the network. As the TCP congestion window continues to increase in size, these various equipment queues overflow, causing packet loss and TCP backoff.
	TcpMaxWindowSize *int32 `json:"tcpMaxWindowSize,omitempty"`

	// TlsAllowDowngradeToPlainTextEnabled Indicates whether clients assigned the client profile are allowed to use TLS/SSL encryption to protect the clients' credentials. This setting doesn't encrypt the data that is transmitted after the clients are authenticated and authorized. This also allows connecting client applications to request to downgrade of their TLS/SSL connections to the Message VPN to a plain-text connection, and if that Message VPN allows TLS/SSL connection downgrades, after the clientsʼ login handshake are finished, their connections are downgraded. This means that the clientsʼ authentication data is still encrypted, but the subsequent application data that is transmitted is sent as non-encrypted plain-text. The valid values are 'true (allowed) or 'false (not allowed). The default is 'true'.
	TlsAllowDowngradeToPlainTextEnabled *bool   `json:"tlsAllowDowngradeToPlainTextEnabled,omitempty"`
	Type                                *string `json:"type,omitempty"`
}

// ClientProfileResponse defines model for ClientProfileResponse.
type ClientProfileResponse struct {
	// Data The client profile configured on the event broker service.
	Data ClientProfile                     `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ClientProfileSummary The client profile configured on the event broker service.
type ClientProfileSummary struct {
	// AllowBridgeConnectionsEnabled Indicates whether clients assigned to the client profile are allowed to establish Dynamic Messaging Routing (DMR) links (or bridge links) from the current Message VPN to another Message VPN in a separate event broker service. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowBridgeConnectionsEnabled *bool `json:"allowBridgeConnectionsEnabled,omitempty"`

	// AllowGuaranteedEndpointCreateEnabled Indicates whether clients assigned to the client profile are allowed to create queues or topic endpoints. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowGuaranteedEndpointCreateEnabled *bool `json:"allowGuaranteedEndpointCreateEnabled,omitempty"`

	// AllowGuaranteedMsgReceiveEnabled Indicates whether clients assigned to the client profile are allowed to bind to topic endpoints or queues to receive guaranteed messages. The valid values are 'true' (allowed) or 'false' (not allowed). The default is 'false'.
	AllowGuaranteedMsgReceiveEnabled *bool `json:"allowGuaranteedMsgReceiveEnabled,omitempty"`

	// AllowGuaranteedMsgSendEnabled Indicates whether clients assigned the client profile are allowed to publish guaranteed messages. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'false'.
	AllowGuaranteedMsgSendEnabled *bool `json:"allowGuaranteedMsgSendEnabled,omitempty"`

	// AllowTransactedSessionsEnabled Indicates whether clients assigned to the client profile are allowed to establish transacted sessions or XA sessions. The valid values are 'true' (allowed) and 'false' (not allowed). The default is 'true'.
	AllowTransactedSessionsEnabled *bool `json:"allowTransactedSessionsEnabled,omitempty"`

	// Id The identifier of the client profile.
	Id *string `json:"id,omitempty"`

	// Name The name of the client profile.
	Name string `json:"name"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// ClientProfilesResponse defines model for ClientProfilesResponse.
type ClientProfilesResponse struct {
	Data []ClientProfileSummary            `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// CloneServiceRequest defines model for CloneServiceRequest.
type CloneServiceRequest struct {
	// CustomRouterName <p>The unique prefix for the name of the router for the event broker service. The prefix must be constructed using only lower-case, alphanumeric characters.</p><p>When the customRouterName value is defined, it is added as a prefix to the event broker service node role, and "cn" (custom name) is appended to the end to create the custom router name, for example, "customprimarycn".</p><p> If the customRouterName value is left blank, the prefix defaults to the service id of the event broker service. This is prefixed to the event broker service node role to create the router name, for example, "bd37t1d5h4kprimary".<p><p><b>Note:</b> customRouterName is only supported on event broker versions 10.4 or greater.</p>
	CustomRouterName *string `json:"customRouterName,omitempty"`

	// DatacenterId The identifier of the datacenter.
	DatacenterId string `json:"datacenterId"`

	// EnvironmentId The unique identifier of the environment where you want to create the service.
	//
	// You can only specify an environment identifier when creating services in a Public Region. You cannot specify an environment identifier when creating a service in a Dedicated Region.
	//
	// Creating a service in a Public Region without specifying an environment identifier places it in the default environment.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// Id The unique identifier of the clone service request.
	Id *string `json:"id,omitempty"`

	// Name The event broker service name.
	Name *string `json:"name,omitempty"`

	// ServiceCloneAttributes <p>The event broker service settings that you can specify to clone. The cluster name, client authentication (client user names), and management users are always cloned to the new service.  You can specify one or more of  the following attributes to clone to the new event broker service:</p>
	// <ul>
	// <li>'SERVICE_CONFIGURATION'-The LDAP authentication profiles, LDAP management, SEMP over message bus enabled setting, and SYSLOG configuration settings.</li>
	// <li>'BROKER_CONFIGURATION'-Message VPN settings, such as topics, topic endpoints, queues, ACL profiles, client profiles, REST Delivery Points (including any configured client certificates).</li>
	// <li>'CERTIFICATE_AUTHORITIES'-Domain and Client Certificate Authorities (CAs).</li>
	// </ul>
	// <p>If you don't specify an attribute (default), all the supported settings except for the 'CERTIFICATE_AUTHORITIES' settings are cloned to the new service.</p>
	ServiceCloneAttributes *ServiceCloneAttributes `json:"serviceCloneAttributes,omitempty"`

	// ServiceConnectionEndpoints The collection of service connection endpoints.
	ServiceConnectionEndpoints *[]ConnectionEndpoint `json:"serviceConnectionEndpoints,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// Cluster The DMR cluster details.
type Cluster struct {
	// BackupRouterName The name of the backup event broker.
	BackupRouterName *string `json:"backupRouterName,omitempty"`

	// MonitoringRouterName The name of the monitoring node.
	MonitoringRouterName *string `json:"monitoringRouterName,omitempty"`

	// Name The name of the DMR cluster.
	Name *string `json:"name,omitempty"`

	// Password The password for the cluster.
	Password *string `json:"password,omitempty"`

	// PrimaryRouterName The name of the primary event broker.
	PrimaryRouterName *string `json:"primaryRouterName,omitempty"`

	// RemoteAddress The address of the remote node in the cluster.
	RemoteAddress *string `json:"remoteAddress,omitempty"`

	// SupportedAuthenticationMode The authentication mode between the nodes in the DMR cluster.
	SupportedAuthenticationMode *[]string `json:"supportedAuthenticationMode,omitempty"`
}

// ConnectionEndpoint The connection endpoint.
type ConnectionEndpoint struct {
	// AccessType The connectivity for the connection endpoint. This can be through private IP addresses (PRIVATE) or public Internet (PUBLIC).
	AccessType ConnectionEndpointAccessType `json:"accessType"`

	// Description The description for the connection endpoint.
	Description *string `json:"description,omitempty"`

	// HostNames The hostnames assigned to the connection endpoint.
	HostNames *[]string `json:"hostNames,omitempty"`

	// Id The identifier of the connection endpoint.
	Id *string `json:"id,omitempty"`

	// K8sServiceId The identifier for the Kubernetes service.
	K8sServiceId *string `json:"k8sServiceId,omitempty"`

	// K8sServiceType The connectivity configuration that is used in the Kubernetes cluster.
	K8sServiceType *ConnectionEndpointK8sServiceType `json:"k8sServiceType,omitempty"`

	// Name The name of the connection endpoint.
	Name string `json:"name"`

	// Ports <p>The protocols and port numbers of the connection endpoint. All messaging and management protocols along with the port numbers must be specified in the request.</p>
	// <p>Connection specific protocols. </p>
	// <ul>
	// <li><b>Solace Messaging</b> </li>
	// <ul>
	// <li>'serviceSmfPlainTextListenPort'-Use SMF Host (plain-text) over TCP to connect and exchange messages with the event broker service.</li>
	// <li>'serviceSmfCompressedListenPort'-Use SMF (plain-text) in a compressed format over TCP to connect and exchange messages with the event broker service.</li>
	// <li>'serviceSmfTlsListenPort'-Use secure SMF using TLS over TCP.</li>
	// </ul>
	// <br>
	// <li><b>Solace Web Messaging</b></li>
	// <ul>
	// <li>'serviceWebPlainTextListenPort'-Use WebSocket over HTTP (plain-text).</li>
	// <li>'serviceWebTlsListenPort'-Use WebSocket over secured HTTP.</li>
	// </ul>
	// <br>
	// <li><b>AMQP</b></li>
	// <ul>
	// <li>'serviceAmqpPlainTextListenPort'-Use AMQP (plain-text).</li>
	// <li>'serviceAmqpTlsListenPort'-Use AMQP over a secure TCP connection.</li>
	// </ul>
	// <br>
	// <li><b>MQTT</b></li>
	// <ul>
	// <li>'serviceMqttPlainTextListenPort'-Use MQTT (plain-text).</li>
	// <li>'serviceMqttWebSocketListenPort'-Use MQTT WebSocket (plain-text).</li>
	// <li>'serviceMqttTlsListenPort'-Use secure MQTT.</li>
	// <li>'serviceMqttTlsWebSocketListenPort'-Use WebSocket secured MQTT.</li>
	// </ul>
	// <br>
	// <li><b>REST</b></li>
	// <ul>
	// <li>'serviceRestIncomingPlainTextListenPort'-Use REST messaging (plain-text).</li>
	// <li>'serviceRestIncomingTlsListenPort'-Use secure REST messaging.</li>
	// </ul>
	// <br>
	// <li><b>Management</b></li>
	// <ul>
	// <li>'serviceManagementTlsListenPort'-Use the secured management connection, which uses SEMP to manage the event broker. This port must be enabled on at least one of the service connection endpoints on the event broker service.</li>
	// <li>'managementSshTlsListenPort'-Use a secure port to connect to the event broker service to issue Solace Command Line Interface (CLI). This port provides you with scope-restricted access to the event broker service.</li>
	// </ul>
	// <ul>
	Ports []ServiceConnectionEndpointPort `json:"ports"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// ConnectionEndpointAccessType The connectivity for the connection endpoint. This can be through private IP addresses (PRIVATE) or public Internet (PUBLIC).
type ConnectionEndpointAccessType string

// ConnectionEndpointK8sServiceType The connectivity configuration that is used in the Kubernetes cluster.
type ConnectionEndpointK8sServiceType string

// CreateServiceRequest defines model for CreateServiceRequest.
type CreateServiceRequest struct {
	// ClusterName The name of the DMR cluster.
	ClusterName *string `json:"clusterName,omitempty"`

	// CustomRouterName <p>The unique prefix for the name of the router for the event broker service. The prefix must be constructed using only lower-case, alphanumeric characters.</p><p>When the customRouterName value is defined, it’s value is added as a prefix to the high-availability role ("primary", "backup", or "monitoring"), and "cn" (custom name) is appended to the end to create the custom router name. For example, if you specified a value of "custom", the router name is "customprimarycn".</p><p> If the customRouterName value is left blank, the prefix defaults to the service id of the event broker service. This is prefixed to the event broker service node role to create the router name, for example, "bd37t1d5h4kprimary".<p><p><b>Note:</b> customRouterName is only supported on event broker versions 10.4 or later.</p>
	CustomRouterName *string `json:"customRouterName,omitempty"`

	// DatacenterId The identifier of the datacenter.
	DatacenterId string `json:"datacenterId"`

	// EnvironmentId The unique identifier of the environment where you want to create the service.
	//
	// You can only specify an environment identifier when creating services in a Public Region. You cannot specify an environment identifier when creating a service in a Dedicated Region.
	//
	// Creating a service in a Public Region without specifying an environment identifier places it in the default environment.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// EventBrokerVersion The event broker version. A default version is provided when this is not specified.
	EventBrokerVersion *string `json:"eventBrokerVersion,omitempty"`

	// Id The unique identifier of the create service request.
	Id *string `json:"id,omitempty"`

	// Locked Indicates if you can delete the event broker service after creating it.  The default value is false, and the valid values are:  <p><ul><li>'true' - you cannot delete this service</li><li>'false' - you can delete this service</li></ul></p>
	Locked *bool `json:"locked,omitempty"`

	// MaxSpoolUsage The message spool size, in gigabytes (GB). A default message spool size is provided if this is not specified.
	MaxSpoolUsage *int32 `json:"maxSpoolUsage,omitempty"`

	// MsgVpnName The message VPN name. A default message VPN name is provided when this is not specified.
	MsgVpnName *string `json:"msgVpnName,omitempty"`

	// Name The event broker service name.
	Name string `json:"name"`

	// RedundancyGroupSslEnabled Enable or disable SSL for the redundancy group (for mate-link encryption).  The default value is false and the valid values are: <p><ul><li>'true' - enabled</li><li>'false' - disabled</li></ul></p>
	RedundancyGroupSslEnabled *bool `json:"redundancyGroupSslEnabled,omitempty"`

	// ServiceClassId Supported service classes.
	ServiceClassId ServiceClassId `json:"serviceClassId"`

	// ServiceConnectionEndpoints The collection of service connection endpoints. If you do not provide parameters for the service connection endpoint, a private endpoint (for Dedicated Regions and Customer-Controlled Regions) or a public endpoint (for Public Regions) is created.
	ServiceConnectionEndpoints *[]ConnectionEndpoint `json:"serviceConnectionEndpoints,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// Datacenter defines model for Datacenter.
type Datacenter struct {
	// Available Indicates whether the datacenter is available.
	Available bool `json:"available"`

	// CloudAgentVersion The version of the Mission Control Agent.
	CloudAgentVersion *string `json:"cloudAgentVersion,omitempty"`

	// CreatedBy The unique identifier representing the user who created the datacenter.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedTime The time the datacenter was created, in ISO 8601 date/time format.
	CreatedTime *time.Time `json:"createdTime,omitempty"`

	// DatacenterType The type of the datacenter, in terms of ownership. The valus can be a Public Region( 'SolacePublic'), a Dedicated Region('SolaceDedicated'), or a Customer-Controlled Region ('CustomerCloud' or 'CustomerOnPrem').
	DatacenterType string `json:"datacenterType"`

	// EnvironmentId The unique identifier of the datacenter's environment.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// Id The identifier of the datacenter.
	Id *string `json:"id,omitempty"`

	// K8sServiceType The type of the Kubernetes service. The values can be 'LOADBALANCER' or 'NODEPORT'.
	K8sServiceType *DatacenterK8sServiceType `json:"k8sServiceType,omitempty"`
	Location       *Location                 `json:"location,omitempty"`

	// Name The name of the datacenter.
	Name string `json:"name"`

	// NumSupportedPrivateEndpoints The number of supported private endpoints.
	NumSupportedPrivateEndpoints *int32 `json:"numSupportedPrivateEndpoints,omitempty"`

	// NumSupportedPublicEndpoints The number of supported public endpoints.
	NumSupportedPublicEndpoints *int32 `json:"numSupportedPublicEndpoints,omitempty"`

	// OperState The operational state of the datacenter. The values can be 'up' or 'down'.
	OperState string `json:"operState"`

	// OrganizationId The identifier of the datacenter's organization.
	OrganizationId *string `json:"organizationId,omitempty"`

	// Provider The name of the cloud provider for the datacenter.
	Provider string `json:"provider"`

	// RegionId The unique identifier for the datacenter region.
	RegionId *string `json:"regionId,omitempty"`

	// SpoolScaleUpCapabilityInfo <p>Deprecation Date: 2025-02-01</p>
	// <p>Removal Date: 2025-04-01</p>
	// <p>Reason: Spool scale-up tests are no longer required, as all Kubernetes-based datacenters provide this capability.</p>
	// Deprecated:
	SpoolScaleUpCapabilityInfo *SpoolScaleUpCapabilityInfo `json:"spoolScaleUpCapabilityInfo,omitempty"`

	// SupportedServiceClasses The list of supported service classes in the datacenter.
	SupportedServiceClasses *[]ServiceClassId `json:"supportedServiceClasses,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// UpdatedBy The unique identifier representing the user who last updated the datacenter.
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// UpdatedTime The time of the last update was performed on the datacenter, in ISO 8601 date/time format.
	UpdatedTime *time.Time `json:"updatedTime,omitempty"`

	// Visible Indicates whether the datacenter is visible.
	Visible bool `json:"visible"`
}

// DatacenterK8sServiceType The type of the Kubernetes service. The values can be 'LOADBALANCER' or 'NODEPORT'.
type DatacenterK8sServiceType string

// DatacenterRequest defines model for DatacenterRequest.
type DatacenterRequest struct {
	// EnvironmentId The unique identifier of the datacenter's environment.
	EnvironmentId *string `json:"environmentId,omitempty"`
}

// DatacenterResponse defines model for DatacenterResponse.
type DatacenterResponse struct {
	Data Datacenter                        `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// DatacentersResponse defines model for DatacentersResponse.
type DatacentersResponse struct {
	Data []Datacenter                      `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// Environment defines model for Environment.
type Environment struct {
	// AllowServiceCreationInPublicRegions When this setting is false, it blocks the creation of services in public regions in this environment.
	AllowServiceCreationInPublicRegions *bool `json:"allowServiceCreationInPublicRegions,omitempty"`

	// Id The unique identifier for this environment.
	Id *string `json:"id,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// EnvironmentRequest defines model for EnvironmentRequest.
type EnvironmentRequest struct {
	// AllowServiceCreationInPublicRegions When this setting is false, it blocks the creation of services in public regions in this environment.
	AllowServiceCreationInPublicRegions *bool `json:"allowServiceCreationInPublicRegions,omitempty"`
}

// EnvironmentResponse defines model for EnvironmentResponse.
type EnvironmentResponse struct {
	Data Environment                       `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// Error defines model for Error.
type Error struct {
	// ErrorId A universally unique identifier (UUID) is useful for debugging. You can provide this code as part of the information you send to our support team.
	ErrorId *string `json:"errorId,omitempty"`

	// Message A user-friendly message describing the reason for the error or what went wrong.
	Message *string `json:"message,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// ErrorId The UUID (Universally Unique Identifier) that is logged with an appropriate stack trace for a WARN or ERROR log that allows support to better determine what cause the error.
	ErrorId *string `json:"errorId,omitempty"`

	// Message A user-friendly message that describes the error.
	Message *string                            `json:"message,omitempty"`
	Meta    *map[string]map[string]interface{} `json:"meta,omitempty"`

	// ValidationDetails When applicable, these are the details of issues with the fields provided for the REST call.
	ValidationDetails *map[string][]string `json:"validationDetails,omitempty"`
}

// EventBrokerServiceVersion The event broker service version.
type EventBrokerServiceVersion struct {
	// Capabilities The capabilities of the event broker service.
	Capabilities []string `json:"capabilities"`

	// ContainerImageTag The container image tag that will be pulled when creating the event broker.
	ContainerImageTag string `json:"containerImageTag"`

	// CurrentMcaVersion The current Mission Control Agent version.
	CurrentMcaVersion *string `json:"currentMcaVersion,omitempty"`

	// EndOfFullSupport The date full support for the event broker version ends in ISO 8601 date/time format.
	EndOfFullSupport time.Time `json:"endOfFullSupport"`

	// EndOfTechnicalSupport The date technical support for the event broker version ends in ISO 8601 date/time format.
	EndOfTechnicalSupport time.Time `json:"endOfTechnicalSupport"`

	// Id Event broker service id.
	Id *string `json:"id,omitempty"`

	// MinimumK8sVersion The minimum Kubernetes cluster version required to deploy this event broker version.
	MinimumK8sVersion string `json:"minimumK8sVersion"`

	// MinimumMcaVersion The minimum Mission Control Agent version required to deploy this event broker version.
	MinimumMcaVersion string `json:"minimumMcaVersion"`

	// Recommended Indicates if the version is recommended.
	Recommended *bool `json:"recommended,omitempty"`

	// ReleaseChannel "The release channel indicates the type of release, either Production or Preview. The release types offer differing support and upgrade paths. See the documentation for more information.
	ReleaseChannel ReleaseChannel `json:"releaseChannel"`

	// ReleaseDate The date the event broker version was released, in ISO 8601 date/time format.
	ReleaseDate time.Time `json:"releaseDate"`

	// ReleaseNotes Release notes describing the content of this event broker version.
	ReleaseNotes string `json:"releaseNotes"`

	// SupportedServiceClasses Supported service classes.
	SupportedServiceClasses []ServiceClassId `json:"supportedServiceClasses"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// Version Event broker service version.
	Version string `json:"version"`
}

// EventBrokerServiceVersionDetails The event broker service version details.
type EventBrokerServiceVersionDetails struct {
	// ReleaseStatus The event broker service version release status.
	ReleaseStatus *EventBrokerServiceVersionDetailsReleaseStatus `json:"releaseStatus,omitempty"`

	// ReleaseStatusDetails The event broker service version release status details.
	ReleaseStatusDetails *string `json:"releaseStatusDetails,omitempty"`
}

// EventBrokerServiceVersionDetailsReleaseStatus The event broker service version release status.
type EventBrokerServiceVersionDetailsReleaseStatus string

// EventBrokerServiceVersionsResponse defines model for EventBrokerServiceVersionsResponse.
type EventBrokerServiceVersionsResponse struct {
	Data []EventBrokerServiceVersion       `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// EventBrokerVersions defines model for EventBrokerVersions.
type EventBrokerVersions struct {
	DefaultEventBrokerVersion   *string `json:"defaultEventBrokerVersion,omitempty"`
	Id                          *string `json:"id,omitempty"`
	LatestK8sEventBrokerVersion *string `json:"latestK8sEventBrokerVersion,omitempty"`
	Type                        *string `json:"type,omitempty"`
}

// EventBrokerVersionsResponse defines model for EventBrokerVersionsResponse.
type EventBrokerVersionsResponse struct {
	Data EventBrokerVersions               `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// InfrastructureDetails Infrastructure details per service. Available on expand only.
type InfrastructureDetails struct {
	// BackupNodeHostname The backup node hostname.
	BackupNodeHostname *string `json:"backupNodeHostname,omitempty"`

	// InfrastructureId The identifier of the infrastructure.
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// MonitoringNodeHostname The monitoring node hostname.
	MonitoringNodeHostname *string `json:"monitoringNodeHostname,omitempty"`

	// PrimaryNodeHostname The primary node hostname.
	PrimaryNodeHostname *string `json:"primaryNodeHostname,omitempty"`
}

// InstallCertificateRequest defines model for InstallCertificateRequest.
type InstallCertificateRequest struct {
	Passphrase *string `json:"passphrase,omitempty"`
}

// LdapProfile The LDAP profiles configured for the event broker service.
type LdapProfile struct {
	// Name The name of the LDAP profile.
	Name *string `json:"name,omitempty"`
}

// LimitClassUsage The service class usage and limits
type LimitClassUsage struct {
	InUse *int32 `json:"inUse,omitempty"`
	Limit *int32 `json:"limit,omitempty"`
}

// Location defines model for Location.
type Location struct {
	// Continent The name of the continent where the datacenter is located.
	Continent string `json:"continent"`

	// Latitude The latitude coordinate of the location for the datacenter.
	Latitude string `json:"latitude"`

	// Longitude The longitude coordinate of the location for the datacenter.
	Longitude string `json:"longitude"`
}

// LoginCredential The login credentials for the event broker service.
type LoginCredential struct {
	// Password The password to log into the event broker service.
	Password *string `json:"password,omitempty"`

	// Username The username to log into the event broker service.
	Username *string `json:"username,omitempty"`
}

// ManagementLoginCredential The mission control manager login credentials
type ManagementLoginCredential struct {
	// Password The password to log into the event broker service.
	Password *string `json:"password,omitempty"`

	// Token The token for management access.
	Token *string `json:"token,omitempty"`

	// Username The username to log into the event broker service.
	Username *string `json:"username,omitempty"`
}

// MessageSpool defines model for MessageSpool.
type MessageSpool struct {
	Id *string `json:"id,omitempty"`

	// MessageSpoolSizeInGB The new size of the message spool in gigabytes (GB).
	MessageSpoolSizeInGB int32 `json:"messageSpoolSizeInGB"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// MessageSpoolDetails Message Spool details per service. Available on expand only.
type MessageSpoolDetails struct {
	// DefaultGbSize The default spool size for the service class in GB.
	DefaultGbSize *int32 `json:"defaultGbSize,omitempty"`

	// ExpandedGbBilled The number of GB billed for the service class.
	ExpandedGbBilled *int32 `json:"expandedGbBilled,omitempty"`

	// TotalGbSize The total spool size in GB.
	TotalGbSize *int32 `json:"totalGbSize,omitempty"`
}

// MessageSpoolLimitClassesResponse defines model for MessageSpoolLimitClassesResponse.
type MessageSpoolLimitClassesResponse struct {
	Data []MessageSpoolLimitUsage          `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// MessageSpoolLimitUsage defines model for MessageSpoolLimitUsage.
type MessageSpoolLimitUsage struct {
	// AddonLimit Message spool expansion addon limit.
	AddonLimit *int32 `json:"addonLimit,omitempty"`

	// AddonUsed  Message spool expansion addons used.
	AddonUsed *int32 `json:"addonUsed,omitempty"`

	// Id The unique identifier.
	Id *string `json:"id,omitempty"`

	// Limit The total amount of message spool expansion available.
	Limit *int32 `json:"limit,omitempty"`

	// Name The name of the limit.
	Name *string `json:"name,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// Used The amount of message spool expansion used.
	Used *int32 `json:"used,omitempty"`
}

// MsgVpn The list of Message VPNs configured on the event broker service.
type MsgVpn struct {
	// AuthenticationBasicEnabled Indicates whether basic authentication is enabled.
	AuthenticationBasicEnabled *bool `json:"authenticationBasicEnabled,omitempty"`

	// AuthenticationBasicType The authentication type.
	AuthenticationBasicType *MsgVpnAuthenticationBasicType `json:"authenticationBasicType,omitempty"`

	// AuthenticationClientCertEnabled Indicates whether client certificate authentication is enabled.
	AuthenticationClientCertEnabled *bool `json:"authenticationClientCertEnabled,omitempty"`

	// AuthenticationClientCertValidateDateEnabled Indicates whether the validation of the 'Not Before' and 'Not After' dates in a client certificate is enabled.
	AuthenticationClientCertValidateDateEnabled *bool `json:"authenticationClientCertValidateDateEnabled,omitempty"`

	// AuthenticationOauthEnabled Indicates whether OAuth authentication is enabled for the Message VPN.
	AuthenticationOauthEnabled *bool `json:"authenticationOauthEnabled,omitempty"`

	// ClientProfiles The client profiles configured on the Message VPN.
	ClientProfiles *[]ClientProfileBase `json:"clientProfiles,omitempty"`

	// Enabled Enabled
	Enabled *bool `json:"enabled,omitempty"`

	// EventLargeMsgThreshold The large message threshold generates events when the size of a message in a Message VPN exceeds a specified size.
	EventLargeMsgThreshold *int32 `json:"eventLargeMsgThreshold,omitempty"`

	// ManagementAdminLoginCredential The mission control manager login credentials
	ManagementAdminLoginCredential *ManagementLoginCredential `json:"managementAdminLoginCredential,omitempty"`

	// MaxConnectionCount The maximum number of clients that are permitted to simultaneously connect to the Message VPN.
	MaxConnectionCount *int32 `json:"maxConnectionCount,omitempty"`

	// MaxEgressFlowCount The maximum number of egress flows (that is, Guaranteed message client receive flows or consumer flows) that can be created by a single client.
	MaxEgressFlowCount *int32 `json:"maxEgressFlowCount,omitempty"`

	// MaxEndpointCount The maximum number of flows that can bind to a non-exclusive durable topic endpoint.
	MaxEndpointCount *int32 `json:"maxEndpointCount,omitempty"`

	// MaxIngressFlowCount The total permitted number of ingress flows (that is, Guaranteed Message client publish flows) for a Message VPN.
	MaxIngressFlowCount *int32 `json:"maxIngressFlowCount,omitempty"`

	// MaxMsgSpoolUsage The maximum message spool usage.
	MaxMsgSpoolUsage *int32 `json:"maxMsgSpoolUsage,omitempty"`

	// MaxSubscriptionCount The maximum number of unique subscriptions.
	MaxSubscriptionCount *int32 `json:"maxSubscriptionCount,omitempty"`

	// MaxTransactedSessionCount The maximum number of simultaneous transacted sessions and/or XA Sessions allowed for the given Message VPN.
	MaxTransactedSessionCount *int32 `json:"maxTransactedSessionCount,omitempty"`

	// MaxTransactionCount The total number of simultaneous transactions (both local transactions and transactions within distributed/XA transaction branches) in a Message VPN.
	MaxTransactionCount *int32 `json:"maxTransactionCount,omitempty"`

	// MissionControlManagerLoginCredential The mission control manager login credentials
	MissionControlManagerLoginCredential *ManagementLoginCredential `json:"missionControlManagerLoginCredential,omitempty"`

	// MsgVpnName The name of the Message VPN.
	MsgVpnName *string `json:"msgVpnName,omitempty"`

	// SempOverMessageBus Indicates whether SEMP-Over-Message-Bus attributes is enabled.
	SempOverMessageBus *SEMPOverMsgBus `json:"sempOverMessageBus,omitempty"`

	// ServiceLoginCredential The login credentials for the event broker service.
	ServiceLoginCredential *LoginCredential `json:"serviceLoginCredential,omitempty"`

	// SubDomainName The generated hostname assigned for the Message VPN.  For example, 'mr54hcalmefac.messaging.solace.cloud'.
	SubDomainName *string `json:"subDomainName,omitempty"`

	// TruststoreUri The URI for the SSL trust store.
	TruststoreUri *string `json:"truststoreUri,omitempty"`
}

// MsgVpnAuthenticationBasicType The authentication type.
type MsgVpnAuthenticationBasicType string

// Operation defines model for Operation.
type Operation struct {
	// CompletedTime The completion time, whether it was successful or failed, in ISO 8601 date/time format.
	CompletedTime *string `json:"completedTime,omitempty"`

	// CreatedBy The unique identifier representing the user who created the operation.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedTime The time the operation was created, in ISO 8601 date/time format.
	CreatedTime *string `json:"createdTime,omitempty"`
	Error       *Error  `json:"error,omitempty"`

	// Id Operations requiring time to complete provide an operation identifier so you can query their progress.
	Id *string `json:"id,omitempty"`

	// OperationType The type of operation against the resource.
	OperationType *OperationOperationType `json:"operationType,omitempty"`

	// ResourceId The resource ID that the operation belongs to.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResourceType The resource type that the operation belongs to.
	ResourceType *string `json:"resourceType,omitempty"`

	// Status The status of the operation.
	Status *OperationStatus `json:"status,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// OperationOperationType The type of operation against the resource.
type OperationOperationType string

// OperationStatus The status of the operation.
type OperationStatus string

// OperationResponse defines model for OperationResponse.
type OperationResponse struct {
	Data Operation                         `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ProvisionedEndpointSpoolUsageAlertThresholds The clear ('clearPercent') and raise ('setPercent') threshold values that determine when to generate events for the percentage amount of the message spool used by all endpoints provisioned by clients for the given client profile.
type ProvisionedEndpointSpoolUsageAlertThresholds struct {
	// ClearPercent The raise threshold value for the message spool usage (as a percentage).
	ClearPercent *int32 `json:"clearPercent,omitempty"`

	// SetPercent The clear threshold value for the message spool usage (as a percentage).
	SetPercent *int32 `json:"setPercent,omitempty"`
}

// ReleaseChannel "The release channel indicates the type of release, either Production or Preview. The release types offer differing support and upgrade paths. See the documentation for more information.
type ReleaseChannel string

// SEMPOverMsgBus Indicates whether SEMP-Over-Message-Bus attributes is enabled.
type SEMPOverMsgBus struct {
	// SempAccessToAdminCmdsEnabled Indicates if users with admin access can use SEMP commands. The default value is false and the valid values are:  <p><ul><li>'true' - can use SEMP commands</li><li>'false' - cannot use SEMP commands</li></ul></p>
	SempAccessToAdminCmdsEnabled *bool `json:"sempAccessToAdminCmdsEnabled,omitempty"`

	// SempAccessToCacheCmdsEnabled SEMP Access to Cache Commands Enabled
	SempAccessToCacheCmdsEnabled *bool `json:"sempAccessToCacheCmdsEnabled,omitempty"`

	// SempAccessToClientAdminCmdsEnabled Indicates whether access to SEMP Client-Admin commands is enabled.
	SempAccessToClientAdminCmdsEnabled *bool `json:"sempAccessToClientAdminCmdsEnabled,omitempty"`

	// SempAccessToShowCmdsEnabled Indicates if users without admin access can see ‘show' commands in SEMP. The default value is false and the valid values are:  <p><ul><li>'true' - can see 'show' SEMP commands</li><li>'false' - cannot see 'show' SEMP commands</li></ul></p>
	SempAccessToShowCmdsEnabled *bool `json:"sempAccessToShowCmdsEnabled,omitempty"`

	// SempOverMsgBusEnabled Indicates whether SEMP over Message Bus is enabled.  When enabled for a Message VPN, clients have access to a limited subset of the event broker management commands.
	SempOverMsgBusEnabled *bool `json:"sempOverMsgBusEnabled,omitempty"`
}

// SempError defines model for SempError.
type SempError struct {
	Code        *string `json:"code,omitempty"`
	Description *string `json:"description,omitempty"`
	Status      *string `json:"status,omitempty"`
}

// SempRequest defines model for SempRequest.
type SempRequest struct {
	Method *string `json:"method,omitempty"`
	Uri    *string `json:"uri,omitempty"`
}

// ServerCertificate defines model for ServerCertificate.
type ServerCertificate struct {
	// CertificateType The certificate type.
	CertificateType *CertificateType `json:"certificateType,omitempty"`

	// Id The unique identifier for the server certificate. The server certificate ID is a combination of the event broker service ID where the server certificate is uploaded and the path to the server certificate.
	Id *string `json:"id,omitempty"`

	// Installed Indicates whether the certificate is installed.
	Installed *bool `json:"installed,omitempty"`

	// InstalledCertificateDetails This field appears only for an installed server certificate. The field provides information about the server certificate, and subject public key in a string, including: Serial Number, Signature Algorithm, Issuer, Validity dates, Subject, and Subject public key info. The Subject public key info includes: Public Key Algorithm, RSA Public Key value, and Modulus.This field is only present when the certificate is installed.
	InstalledCertificateDetails *string `json:"installedCertificateDetails,omitempty"`

	// SerialNumber The server certificate’s serial number. The certificate authority issues the serial number, which uniquely identifies the certificate.
	SerialNumber *string `json:"serialNumber,omitempty"`

	// Sha1Thumbprint The server certificate's SHA-1 Thumbprint. This value is the SHA-1 digest of the server certificate under DER form.  Equivalent of 'openssl x509 -fingerprint'.
	Sha1Thumbprint *string `json:"sha1Thumbprint,omitempty"`

	// SubjectCN The server certificate’s common name (CN).
	SubjectCN *string `json:"subjectCN,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// ValidityNotAfter The date the server certificate expires, in ISO 8601 date/time format.
	ValidityNotAfter *string `json:"validityNotAfter,omitempty"`

	// ValidityNotBefore The date the server certificate is valid from in ISO 8601 date/time format.
	ValidityNotBefore *string `json:"validityNotBefore,omitempty"`
}

// ServerCertificateResponse defines model for ServerCertificateResponse.
type ServerCertificateResponse struct {
	Data ServerCertificate                 `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ServerCertificateSummary defines model for ServerCertificateSummary.
type ServerCertificateSummary struct {
	// CertificateType The certificate type.
	CertificateType *CertificateType `json:"certificateType,omitempty"`

	// Id The unique identifier for the server certificate. The server certificate ID is a combination of the event broker service ID where the server certificate is uploaded and the path to the server certificate.
	Id *string `json:"id,omitempty"`

	// Installed Indicates whether the certificate is installed.
	Installed *bool `json:"installed,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`
}

// ServerCertificateSummaryResponse defines model for ServerCertificateSummaryResponse.
type ServerCertificateSummaryResponse struct {
	Data []ServerCertificateSummary        `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// Service defines model for Service.
type Service struct {
	// AdminState The administration state of the event broker service.
	AdminState *ServiceAdminState `json:"adminState,omitempty"`

	// AllowedActions The allowed actions the user can perform on the event broker service and its configurations,  including: '<code>get</code>','<code>configure</code>','<code>update</code>','<code>broker_update</code>','<code>delete</code>','<code>assign</code>'.
	AllowedActions *[]string `json:"allowedActions,omitempty"`

	// Broker Broker Details available on expand only.
	Broker *Broker `json:"broker,omitempty"`

	// CreatedBy The unique identifier representing the user who created the event broker service.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedTime The time the event broker service was created, in ISO 8601 date/time format.
	CreatedTime *time.Time `json:"createdTime,omitempty"`

	// CreationState The creation state of the event broker service.
	CreationState *ServiceCreationState `json:"creationState,omitempty"`

	// DatacenterId The identifier of the datacenter.
	DatacenterId *string `json:"datacenterId,omitempty"`

	// DefaultManagementHostname Default management hostname.
	DefaultManagementHostname *string `json:"defaultManagementHostname,omitempty"`

	// EnvironmentId The unique identifier of the environment the service is associated with.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// ErrorId The error ID if the event broker service creation failed.
	ErrorId *string `json:"errorId,omitempty"`

	// ErrorMessage The error message if the event broker service creation failed.
	ErrorMessage              *string `json:"errorMessage,omitempty"`
	EventBrokerServiceVersion string  `json:"eventBrokerServiceVersion"`

	// EventBrokerServiceVersionDetails The event broker service version details.
	EventBrokerServiceVersionDetails *EventBrokerServiceVersionDetails `json:"eventBrokerServiceVersionDetails,omitempty"`

	// EventMeshId The identifier of the event mesh for which the event broker service belongs, if applicable.
	EventMeshId *string `json:"eventMeshId,omitempty"`

	// Id The identifier of the event broker service.
	Id *string `json:"id,omitempty"`

	// InfrastructureDetails Infrastructure details per service. Available on expand only.
	InfrastructureDetails *InfrastructureDetails `json:"infrastructureDetails,omitempty"`

	// InfrastructureId A unique identifier representing for the infrastructure of the event broker service.
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// Locked Indicates whether the event broker service has deletion protection enabled. The valid values are 'true' (enabled) or 'false' (disabled).
	Locked *bool `json:"locked,omitempty"`

	// MessageSpoolDetails Message Spool details per service. Available on expand only.
	MessageSpoolDetails *MessageSpoolDetails `json:"messageSpoolDetails,omitempty"`

	// MsgVpnName The name of the event broker service Message VPN.
	MsgVpnName *string `json:"msgVpnName,omitempty"`

	// Name The name of the event broker service.
	Name *string `json:"name,omitempty"`

	// OngoingOperationIds The operation identifiers for an ongoing operation on the event broker service.
	OngoingOperationIds *[]string `json:"ongoingOperationIds,omitempty"`

	// OwnedBy The unique identifier representing the user who owns the event broker service.
	OwnedBy *string `json:"ownedBy,omitempty"`

	// ServiceClassId Supported service classes.
	ServiceClassId *ServiceClassId `json:"serviceClassId,omitempty"`

	// ServiceConnectionEndpoints Connection Endpoints available on expand only.
	ServiceConnectionEndpoints *[]ConnectionEndpoint `json:"serviceConnectionEndpoints,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// UpdatedBy The unique identifier representing the user who last updated the event broker service.
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// UpdatedTime The time of the last update was performed on the event broker service, in ISO 8601 date/time format.
	UpdatedTime *time.Time `json:"updatedTime,omitempty"`
}

// ServiceAdminState The administration state of the event broker service.
type ServiceAdminState string

// ServiceClass defines model for ServiceClass.
type ServiceClass struct {
	// BrokerScalingTier The underlying scaling tiers for the software event broker.
	BrokerScalingTier *string `json:"brokerScalingTier,omitempty"`

	// HighAvailabilityCapable Indicates whether the service class supports High-Availability. A value of 'True' indicates that high-availability is supported.
	HighAvailabilityCapable *bool `json:"highAvailabilityCapable,omitempty"`

	// Id Supported service classes.
	Id *ServiceClassId `json:"id,omitempty"`

	// Limits The service class usage and limits
	Limits *[]LimitClassUsage `json:"limits,omitempty"`

	// MaxNumberVpns The maximum number of Message VPNs for the service class.
	MaxNumberVpns *int32 `json:"maxNumberVpns,omitempty"`

	// Name The name of the service class.
	Name *string `json:"name,omitempty"`

	// Type The type of object for internal informational purposes.
	Type *string `json:"type,omitempty"`

	// VpnConnections The maximum number of client connections for the service class.
	VpnConnections *int32 `json:"vpnConnections,omitempty"`

	// VpnMaxSpoolSize The maximum message spool size of the service class, in gigabytes (GB).
	VpnMaxSpoolSize *int32 `json:"vpnMaxSpoolSize,omitempty"`
}

// ServiceClassId Supported service classes.
type ServiceClassId string

// ServiceClassResponse defines model for ServiceClassResponse.
type ServiceClassResponse struct {
	Data ServiceClass                      `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ServiceClassesResponse defines model for ServiceClassesResponse.
type ServiceClassesResponse struct {
	Data []ServiceClass                    `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ServiceCloneAttributes <p>The event broker service settings that you can specify to clone. The cluster name, client authentication (client user names), and management users are always cloned to the new service.  You can specify one or more of  the following attributes to clone to the new event broker service:</p>
// <ul>
// <li>'SERVICE_CONFIGURATION'-The LDAP authentication profiles, LDAP management, SEMP over message bus enabled setting, and SYSLOG configuration settings.</li>
// <li>'BROKER_CONFIGURATION'-Message VPN settings, such as topics, topic endpoints, queues, ACL profiles, client profiles, REST Delivery Points (including any configured client certificates).</li>
// <li>'CERTIFICATE_AUTHORITIES'-Domain and Client Certificate Authorities (CAs).</li>
// </ul>
// <p>If you don't specify an attribute (default), all the supported settings except for the 'CERTIFICATE_AUTHORITIES' settings are cloned to the new service.</p>
type ServiceCloneAttributes struct {
	Components *[]ServiceCloneAttributesComponents `json:"components,omitempty"`
}

// ServiceCloneAttributesComponents defines model for ServiceCloneAttributes.Components.
type ServiceCloneAttributesComponents string

// ServiceConnectionEndpointPort <p>The protocols and port numbers of the connection endpoint. All messaging and management protocols along with the port numbers must be specified in the request.</p>
// <p>Connection specific protocols. </p>
// <ul>
// <li><b>Solace Messaging</b> </li>
// <ul>
// <li>'serviceSmfPlainTextListenPort'-Use SMF Host (plain-text) over TCP to connect and exchange messages with the event broker service.</li>
// <li>'serviceSmfCompressedListenPort'-Use SMF (plain-text) in a compressed format over TCP to connect and exchange messages with the event broker service.</li>
// <li>'serviceSmfTlsListenPort'-Use secure SMF using TLS over TCP.</li>
// </ul>
// <br>
// <li><b>Solace Web Messaging</b></li>
// <ul>
// <li>'serviceWebPlainTextListenPort'-Use WebSocket over HTTP (plain-text).</li>
// <li>'serviceWebTlsListenPort'-Use WebSocket over secured HTTP.</li>
// </ul>
// <br>
// <li><b>AMQP</b></li>
// <ul>
// <li>'serviceAmqpPlainTextListenPort'-Use AMQP (plain-text).</li>
// <li>'serviceAmqpTlsListenPort'-Use AMQP over a secure TCP connection.</li>
// </ul>
// <br>
// <li><b>MQTT</b></li>
// <ul>
// <li>'serviceMqttPlainTextListenPort'-Use MQTT (plain-text).</li>
// <li>'serviceMqttWebSocketListenPort'-Use MQTT WebSocket (plain-text).</li>
// <li>'serviceMqttTlsListenPort'-Use secure MQTT.</li>
// <li>'serviceMqttTlsWebSocketListenPort'-Use WebSocket secured MQTT.</li>
// </ul>
// <br>
// <li><b>REST</b></li>
// <ul>
// <li>'serviceRestIncomingPlainTextListenPort'-Use REST messaging (plain-text).</li>
// <li>'serviceRestIncomingTlsListenPort'-Use secure REST messaging.</li>
// </ul>
// <br>
// <li><b>Management</b></li>
// <ul>
// <li>'serviceManagementTlsListenPort'-Use the secured management connection, which uses SEMP to manage the event broker. This port must be enabled on at least one of the service connection endpoints on the event broker service.</li>
// <li>'managementSshTlsListenPort'-Use a secure port to connect to the event broker service to issue Solace Command Line Interface (CLI). This port provides you with scope-restricted access to the event broker service.</li>
// </ul>
// <ul>
type ServiceConnectionEndpointPort struct {
	// Port Port number. Use '0' to disable the port.
	Port *int32 `json:"port,omitempty"`

	// Protocol Messaging or management protocol.
	Protocol ServiceConnectionEndpointPortProtocol `json:"protocol"`
}

// ServiceConnectionEndpointPortProtocol Messaging or management protocol.
type ServiceConnectionEndpointPortProtocol string

// ServiceCreationState The creation state of the event broker service.
type ServiceCreationState string

// ServiceResponse defines model for ServiceResponse.
type ServiceResponse struct {
	Data Service                           `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// ServiceSummary defines model for ServiceSummary.
type ServiceSummary struct {
	// AdminState The administration state of the event broker service.
	AdminState *ServiceAdminState `json:"adminState,omitempty"`

	// AllowedActions The allowed actions the user can perform on the event broker service and its configurations,  including: '<code>get</code>','<code>configure</code>','<code>update</code>','<code>broker_update</code>','<code>delete</code>','<code>assign</code>'.
	AllowedActions *[]string `json:"allowedActions,omitempty"`

	// CreatedBy The unique identifier representing the user who created the event broker service.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedTime The time the event broker service was created, in ISO 8601 date/time format.
	CreatedTime *time.Time `json:"createdTime,omitempty"`

	// CreationState The creation state of the event broker service.
	CreationState *ServiceCreationState `json:"creationState,omitempty"`

	// DatacenterId The identifier of the datacenter.
	DatacenterId *string `json:"datacenterId,omitempty"`

	// EnvironmentId The unique identifier of the environment the service is associated with.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// ErrorId The error ID if the event broker service creation failed.
	ErrorId *string `json:"errorId,omitempty"`

	// ErrorMessage The error message if the event broker service creation failed.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// EventBrokerServiceVersion Event broker service version.
	EventBrokerServiceVersion *string `json:"eventBrokerServiceVersion,omitempty"`

	// EventBrokerServiceVersionDetails The event broker service version details.
	EventBrokerServiceVersionDetails *EventBrokerServiceVersionDetails `json:"eventBrokerServiceVersionDetails,omitempty"`

	// EventMeshId The identifier of the event mesh for which the event broker service belongs, if applicable.
	EventMeshId *string `json:"eventMeshId,omitempty"`

	// Id The identifier of the event broker service.
	Id *string `json:"id,omitempty"`

	// InfrastructureId A unique identifier representing for the infrastructure of the event broker service.
	InfrastructureId *string `json:"infrastructureId,omitempty"`

	// Locked Indicates whether the event broker service has deletion protection enabled. The valid values are 'true' (enabled) or 'false' (disabled).
	Locked *bool `json:"locked,omitempty"`

	// MessageSpoolDetails Message Spool details per service. Available on expand only.
	MessageSpoolDetails *MessageSpoolDetails `json:"messageSpoolDetails,omitempty"`

	// MsgVpnName The name of the event broker service Message VPN.
	MsgVpnName *string `json:"msgVpnName,omitempty"`

	// Name The name of the event broker service.
	Name *string `json:"name,omitempty"`

	// OngoingOperationIds The operation identifiers for an ongoing operation on the event broker service.
	OngoingOperationIds *[]string `json:"ongoingOperationIds,omitempty"`

	// OwnedBy The unique identifier representing the user who owns the event broker service.
	OwnedBy *string `json:"ownedBy,omitempty"`

	// ServiceClassId Supported service classes.
	ServiceClassId *ServiceClassId `json:"serviceClassId,omitempty"`

	// Type The type of object for informational purposes.
	Type *string `json:"type,omitempty"`

	// UpdatedBy The unique identifier representing the user who last updated the event broker service.
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// UpdatedTime The time of the last update was performed on the event broker service, in ISO 8601 date/time format.
	UpdatedTime *time.Time `json:"updatedTime,omitempty"`
}

// ServiceSummaryResponse defines model for ServiceSummaryResponse.
type ServiceSummaryResponse struct {
	Data []ServiceSummary                  `json:"data"`
	Meta map[string]map[string]interface{} `json:"meta"`
}

// SpoolScaleUpCapabilityInfo <p>Deprecation Date: 2025-02-01</p>
// <p>Removal Date: 2025-04-01</p>
// <p>Reason: Spool scale-up tests are no longer required, as all Kubernetes-based datacenters provide this capability.</p>
type SpoolScaleUpCapabilityInfo struct {
	// SpoolScaleUpCapabilityState The current state of  the Scalable Message Spool Size feature. The values can be 'INPROGRESS', 'SUPPORTED', 'NOT SUPPORTED', or 'UNKNOWN'.
	SpoolScaleUpCapabilityState *string `json:"spoolScaleUpCapabilityState,omitempty"`

	// SpoolScaleUpTestMessage Message resulting from a self-test of support for the Scalable Message Spool Size feature.
	SpoolScaleUpTestMessage *string `json:"spoolScaleUpTestMessage,omitempty"`

	// SpoolScaleUpTestTimestamp The time of the last test was performed, in ISO 8601 date/time format.
	SpoolScaleUpTestTimestamp *time.Time `json:"spoolScaleUpTestTimestamp,omitempty"`
}

// UpdateServiceRequest defines model for UpdateServiceRequest.
type UpdateServiceRequest struct {
	// Locked Indicates whether the event broker service has deletion protection enabled. The valid values are 'true' (enabled) or 'false' (disabled). The default is 'false'.
	Locked *bool `json:"locked,omitempty"`

	// Name The new service name. The new service name must be unique within an organization.
	Name *string `json:"name,omitempty"`

	// OwnedBy The owner of the event broker service. The owner must belong to the same organization.
	OwnedBy *string `json:"ownedBy,omitempty"`
}

// UploadCertificateRequest defines model for UploadCertificateRequest.
type UploadCertificateRequest struct {
	Certificate string `json:"certificate"`
	PrivateKey  string `json:"privateKey"`
}

// GetDatacentersParams defines parameters for GetDatacenters.
type GetDatacentersParams struct {
	// PageNumber The page number to retrieve.
	PageNumber *int `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize The number of datacenters to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort <p>The sorting criteria for the returned results. You can sort the results by query
	// parameter in ascending or descending order. Define the sort order using the following string:
	// <code>fieldname:asc/desc</code> where:</p>
	// <ul>
	//         <li><code>fieldname</code>—The field name of the query parameter to sort by.</li>
	//         <li><code>asc</code>—Sort the selected field name in ascending order.</li>
	//         <li><code>desc</code>—Sort the selected field name in descending order.</li>
	// </ul>
	// <p>You can use multiple query parameters to refine the sorting order.</p>
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// DatacenterType <p>Filter the returned query results by datacenter type. The filtering options include:</p>
	// <ul>
	//         <li>'<code>Empty</code>'—Returns all datacenter types.</li>
	//         <li>'<code>Unknown</code>'—Returns any datacenters where the <code>datacenterType</code>
	//         is not set.</li>
	//         <li>'<code>SolacePublic</code>'—Known as Public Regions. Public Regions are cloud-based,
	//         managed datacenters shared between customers.</li>
	//         <li>'<code>SolaceDedicated</code>'—Known as Dedicated Regions. Dedicated Regions are
	//         cloud-based, managed datacenters dedicated to a single-customer.</li>
	//         <li>'<code>CustomerControlled</code>'—Cloud-based Customer-Controlled Regions.</li>
	//         <li>'<code>CustomerOnPrem</code>'—On-premises Customer-Controlled Regions.</li>
	// </ul>
	DatacenterType *GetDatacentersParamsDatacenterType `form:"datacenterType,omitempty" json:"datacenterType,omitempty"`

	// Provider <p>Filter the returned query results by Kubernetes provider type.
	// The filtering options include:</p>
	// <ul>
	//         <li>'<code>aks</code>'-Azure Kubernetes Service.</li>
	//         <li>‘<code>eks</code>’-AWS Elastic Kubernetes Service.</li>
	//         <li>‘<code>gce</code>’-Google Kubernetes Engine.</li>
	//         <li>‘<code>k8s</code>’-Other Kubernetes provider.</li>
	//         <li>‘<code>aws</code>’-(deprecated) VM-based on Amazon Web Services.</li>
	//         <li>‘<code>azure</code>’-(deprecated) VM-based on Azure.</li>
	// </ul>
	Provider *GetDatacentersParamsProvider `form:"provider,omitempty" json:"provider,omitempty"`

	// EnvironmentId <p>Filter the returned query results by an environment's unique identifier. You cannot filter public datacenters using an environment's unique identifier.</p>
	EnvironmentId *string `form:"environmentId,omitempty" json:"environmentId,omitempty"`
}

// GetDatacentersParamsDatacenterType defines parameters for GetDatacenters.
type GetDatacentersParamsDatacenterType string

// GetDatacentersParamsProvider defines parameters for GetDatacenters.
type GetDatacentersParamsProvider string

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// CustomAttributes <p>Filter the list of event broker services by custom attributes.</p><p>To filter by custom attribute name and value, use the format: <code>customAttributes=&lt;custom-attribute-name&gt;==&lt;custom-attribute-value&gt;</code>.</p><code>customAttributes</code> are RSQL query strings that support using asterisks as a wildcard. You can place a wildcard at the beginning, middle, or end of the query value.</p><p>The supported attributes, and examples of each are listed below:</p><ul>
	// <li><code>name</code>, examples include:</li>
	// <ul>
	// <li><code>name==myservice</code></li>
	// <li><code>name==production*</code></li>
	// <li><code>name==*prod*</code></li>
	// </ul>
	// <li><code>ownedBy</code>, examples include:</li>
	// <ul>
	// <li><code>ownedBy==userId</code></li>
	// </ul>
	// <li><code>environmentId</code>, examples include:</li>
	// <ul>
	// <li><code>environmentId==12345</code></li>
	// <li><code>environmentId!=345678</code></li>
	// </ul>
	// </ul>
	CustomAttributes *string `form:"customAttributes,omitempty" json:"customAttributes,omitempty"`

	// Expand <p>Additional information to retrieve for the event broker service. The supported value is <code>allowedActions</code>.</p><p>The returned <code>allowedActions</code> may include: '<code>get</code>', '<code>messageSpoolDetails</code>', '<code>configure</code>', '<code>update</code>', '<code>broker_update</code>', '<code>delete</code>', '<code>assign</code>'.</p><p>The definitions for each action are listed below:</p><li><code>get</code> The user can get the event broker service.</li>
	// <li><code>messageSpoolDetails</code> The user can get the message spool details.</li>
	// <li><code>configure</code> The user can configure the event broker service, for example, to add a new client profile.</li>
	// <li><code>update</code> The user can update the event broker service configurations.</li>
	// <li><code>broker_update</code> The user can update the event broker service message vpn configuration.</li>
	// <li><code>delete</code> The user can delete the event broker service.</li>
	// <li><code>assign</code> The user can assign the event broker service to other users.</li>
	Expand *string `form:"expand,omitempty" json:"expand,omitempty"`

	// Sort <p>Sort the returned event broker services by attribute.</p><p>You can use the following value formats for the sort order:</p><ul>
	// <li><code>attributes-names</code></li>
	// <li><code>attributes-names:sort-order</code></li>
	// </ul><p>Add <code>attribute-names</code> in a comma-separated list in the order you want to sort them by.</p><p>Use the <code>sort-order</code> to sort the attributes using one of the following values:</p><ul>
	// <li>‘<code>asc</code>’-ascending order</li>
	// <li>‘<code>desc</code>’-descending order</li>
	// </ul><p>If you do not define a sort order, it will default to ascending order.
	// These are support attribute names you can sort by:</p><ul>
	// <li>name</li>
	// <li>adminState</li>
	// <li>creationState</li>
	// <li>datacenterId</li>
	// <li>serviceClassId</li>
	// <li>ownedBy</li>
	// <li>createdTime</li>
	// </ul>
	// For example, if you want to get a list of event broker services by name and time of creation, in ascending order, you would enter: <code>datacenterId,createdTime:asc</code>
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// PageNumber The page number to retrieve.
	PageNumber *int `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize The number of event broker services to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetServiceParams defines parameters for GetService.
type GetServiceParams struct {
	// Expand You can request additional information about the event broker service by selecting expand parameters, including connection endpoint information, broker details including version, allowed actions you can perform on the service, and message spool details.
	Expand *[]GetServiceParamsExpand `form:"expand,omitempty" json:"expand,omitempty"`
}

// GetServiceParamsExpand defines parameters for GetService.
type GetServiceParamsExpand string

// GetResourceParams defines parameters for GetResource.
type GetResourceParams struct {
	// CustomQuery The query parameters to pass as part of the SEMP request when retrieving resource objects from the event broker service. For example, you can build the URL as follows:
	// broker/SEMP/v2/config/oauthProfiles/testOAuth?select=msgVpnName,queueName&where=msgVpnName==test&count=25&cursor=1
	// See <a href="objects">Objects</a> for query parameters.
	CustomQuery *map[string]interface{} `form:"customQuery,omitempty" json:"customQuery,omitempty"`
}

// PatchResourceJSONBody defines parameters for PatchResource.
type PatchResourceJSONBody = string

// CreateResourceJSONBody defines parameters for CreateResource.
type CreateResourceJSONBody = string

// ReplaceResourceJSONBody defines parameters for ReplaceResource.
type ReplaceResourceJSONBody = string

// GetClientProfilesParams defines parameters for GetClientProfiles.
type GetClientProfilesParams struct {
	// PageNumber The page number to retrieve.
	PageNumber *int `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize The number of client profiles to return per page.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort The sorting criteria for the list of client profiles.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetServiceClassesParams defines parameters for GetServiceClasses.
type GetServiceClassesParams struct {
	// BrokerFamilyVersion The version of the broker family. For example 10.6
	BrokerFamilyVersion *float32 `form:"brokerFamilyVersion,omitempty" json:"brokerFamilyVersion,omitempty"`
}

// GetServiceClassParams defines parameters for GetServiceClass.
type GetServiceClassParams struct {
	// BrokerFamilyVersion The version of the broker family. For example 10.6
	BrokerFamilyVersion *float32 `form:"brokerFamilyVersion,omitempty" json:"brokerFamilyVersion,omitempty"`
}

// GetServiceClassParamsId defines parameters for GetServiceClass.
type GetServiceClassParamsId string

// UpdateDatacenterJSONRequestBody defines body for UpdateDatacenter for application/json ContentType.
type UpdateDatacenterJSONRequestBody = DatacenterRequest

// PatchEnvironmentJSONRequestBody defines body for PatchEnvironment for application/json ContentType.
type PatchEnvironmentJSONRequestBody = EnvironmentRequest

// CreateServiceJSONRequestBody defines body for CreateService for application/json ContentType.
type CreateServiceJSONRequestBody = CreateServiceRequest

// UpdateServiceJSONRequestBody defines body for UpdateService for application/json ContentType.
type UpdateServiceJSONRequestBody = UpdateServiceRequest

// CloneServiceJSONRequestBody defines body for CloneService for application/json ContentType.
type CloneServiceJSONRequestBody = CloneServiceRequest

// PatchResourceJSONRequestBody defines body for PatchResource for application/json ContentType.
type PatchResourceJSONRequestBody = PatchResourceJSONBody

// CreateResourceJSONRequestBody defines body for CreateResource for application/json ContentType.
type CreateResourceJSONRequestBody = CreateResourceJSONBody

// ReplaceResourceJSONRequestBody defines body for ReplaceResource for application/json ContentType.
type ReplaceResourceJSONRequestBody = ReplaceResourceJSONBody

// CreateClientProfileJSONRequestBody defines body for CreateClientProfile for application/json ContentType.
type CreateClientProfileJSONRequestBody = ClientProfileRequest

// UpdateClientProfileJSONRequestBody defines body for UpdateClientProfile for application/json ContentType.
type UpdateClientProfileJSONRequestBody = ClientProfileRequest

// ReplaceClientProfileJSONRequestBody defines body for ReplaceClientProfile for application/json ContentType.
type ReplaceClientProfileJSONRequestBody = ClientProfileRequest

// UpdateMessageSpoolJSONRequestBody defines body for UpdateMessageSpool for application/json ContentType.
type UpdateMessageSpoolJSONRequestBody = MessageSpool

// DisableOrEnableJSONRequestBody defines body for DisableOrEnable for application/json ContentType.
type DisableOrEnableJSONRequestBody = BasicAuthAvailability

// UploadServerCertificateJSONRequestBody defines body for UploadServerCertificate for application/json ContentType.
type UploadServerCertificateJSONRequestBody = UploadCertificateRequest

// InstallServerCertificateJSONRequestBody defines body for InstallServerCertificate for application/json ContentType.
type InstallServerCertificateJSONRequestBody = InstallCertificateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDatacenters request
	GetDatacenters(ctx context.Context, params *GetDatacentersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatacenter request
	GetDatacenter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatacenterWithBody request with any body
	UpdateDatacenterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatacenter(ctx context.Context, id string, body UpdateDatacenterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventBrokerServiceVersions request
	GetEventBrokerServiceVersions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersions request
	GetVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironment request
	GetEnvironment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchEnvironmentWithBody request with any body
	PatchEnvironmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchEnvironment(ctx context.Context, id string, body PatchEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceWithBody request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteService request
	DeleteService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceWithBody request with any body
	UpdateServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateService(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneServiceWithBody request with any body
	CloneServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloneService(ctx context.Context, id string, body CloneServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResource request
	DeleteResource(ctx context.Context, serviceId string, resourcePath string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, serviceId string, resourcePath string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchResourceWithBody request with any body
	PatchResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchResource(ctx context.Context, serviceId string, resourcePath string, body PatchResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResourceWithBody request with any body
	CreateResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResource(ctx context.Context, serviceId string, resourcePath string, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceResourceWithBody request with any body
	ReplaceResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceResource(ctx context.Context, serviceId string, resourcePath string, body ReplaceResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientProfiles request
	GetClientProfiles(ctx context.Context, serviceId string, params *GetClientProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientProfileWithBody request with any body
	CreateClientProfileWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClientProfile(ctx context.Context, serviceId string, body CreateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClientProfile request
	DeleteClientProfile(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientProfile request
	GetClientProfile(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClientProfileWithBody request with any body
	UpdateClientProfileWithBody(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClientProfile(ctx context.Context, serviceId string, name string, body UpdateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceClientProfileWithBody request with any body
	ReplaceClientProfileWithBody(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceClientProfile(ctx context.Context, serviceId string, name string, body ReplaceClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMessageSpoolWithBody request with any body
	UpdateMessageSpoolWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMessageSpool(ctx context.Context, serviceId string, body UpdateMessageSpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceOperation request
	GetServiceOperation(ctx context.Context, serviceId string, operationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableOrEnableWithBody request with any body
	DisableOrEnableWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableOrEnable(ctx context.Context, serviceId string, body DisableOrEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerCertificates request
	GetAllServerCertificates(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadServerCertificateWithBody request with any body
	UploadServerCertificateWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadServerCertificate(ctx context.Context, serviceId string, body UploadServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerCertificateById request
	DeleteServerCertificateById(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerCertificateById request
	GetServerCertificateById(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallServerCertificateWithBody request with any body
	InstallServerCertificateWithBody(ctx context.Context, serviceId string, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallServerCertificate(ctx context.Context, serviceId string, certificateId string, body InstallServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLimits request
	GetLimits(ctx context.Context, orgId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceClasses request
	GetServiceClasses(ctx context.Context, params *GetServiceClassesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceClass request
	GetServiceClass(ctx context.Context, id GetServiceClassParamsId, params *GetServiceClassParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDatacenters(ctx context.Context, params *GetDatacentersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatacentersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatacenter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatacenterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatacenterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatacenterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatacenter(ctx context.Context, id string, body UpdateDatacenterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatacenterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventBrokerServiceVersions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventBrokerServiceVersionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironment(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironmentWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchEnvironment(ctx context.Context, id string, body PatchEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchEnvironmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateService(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateService(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneServiceWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneServiceRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneService(ctx context.Context, id string, body CloneServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneServiceRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResource(ctx context.Context, serviceId string, resourcePath string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResourceRequest(c.Server, serviceId, resourcePath)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, serviceId string, resourcePath string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, serviceId, resourcePath, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchResourceRequestWithBody(c.Server, serviceId, resourcePath, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchResource(ctx context.Context, serviceId string, resourcePath string, body PatchResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchResourceRequest(c.Server, serviceId, resourcePath, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequestWithBody(c.Server, serviceId, resourcePath, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResource(ctx context.Context, serviceId string, resourcePath string, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResourceRequest(c.Server, serviceId, resourcePath, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResourceWithBody(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResourceRequestWithBody(c.Server, serviceId, resourcePath, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResource(ctx context.Context, serviceId string, resourcePath string, body ReplaceResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResourceRequest(c.Server, serviceId, resourcePath, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientProfiles(ctx context.Context, serviceId string, params *GetClientProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientProfilesRequest(c.Server, serviceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientProfileWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientProfileRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientProfile(ctx context.Context, serviceId string, body CreateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientProfileRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClientProfile(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClientProfileRequest(c.Server, serviceId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClientProfile(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientProfileRequest(c.Server, serviceId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientProfileWithBody(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientProfileRequestWithBody(c.Server, serviceId, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClientProfile(ctx context.Context, serviceId string, name string, body UpdateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClientProfileRequest(c.Server, serviceId, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceClientProfileWithBody(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceClientProfileRequestWithBody(c.Server, serviceId, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceClientProfile(ctx context.Context, serviceId string, name string, body ReplaceClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceClientProfileRequest(c.Server, serviceId, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMessageSpoolWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMessageSpoolRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMessageSpool(ctx context.Context, serviceId string, body UpdateMessageSpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMessageSpoolRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceOperation(ctx context.Context, serviceId string, operationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceOperationRequest(c.Server, serviceId, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableOrEnableWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableOrEnableRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableOrEnable(ctx context.Context, serviceId string, body DisableOrEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableOrEnableRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerCertificates(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerCertificatesRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadServerCertificateWithBody(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadServerCertificateRequestWithBody(c.Server, serviceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadServerCertificate(ctx context.Context, serviceId string, body UploadServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadServerCertificateRequest(c.Server, serviceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerCertificateById(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerCertificateByIdRequest(c.Server, serviceId, certificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerCertificateById(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerCertificateByIdRequest(c.Server, serviceId, certificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallServerCertificateWithBody(ctx context.Context, serviceId string, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallServerCertificateRequestWithBody(c.Server, serviceId, certificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallServerCertificate(ctx context.Context, serviceId string, certificateId string, body InstallServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallServerCertificateRequest(c.Server, serviceId, certificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLimits(ctx context.Context, orgId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLimitsRequest(c.Server, orgId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceClasses(ctx context.Context, params *GetServiceClassesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceClassesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceClass(ctx context.Context, id GetServiceClassParamsId, params *GetServiceClassParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceClassRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDatacentersRequest generates requests for GetDatacenters
func NewGetDatacentersRequest(server string, params *GetDatacentersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/datacenters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DatacenterType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "datacenterType", runtime.ParamLocationQuery, *params.DatacenterType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Provider != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnvironmentId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environmentId", runtime.ParamLocationQuery, *params.EnvironmentId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatacenterRequest generates requests for GetDatacenter
func NewGetDatacenterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/datacenters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatacenterRequest calls the generic UpdateDatacenter builder with application/json body
func NewUpdateDatacenterRequest(server string, id string, body UpdateDatacenterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatacenterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateDatacenterRequestWithBody generates requests for UpdateDatacenter with any type of body
func NewUpdateDatacenterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/datacenters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventBrokerServiceVersionsRequest generates requests for GetEventBrokerServiceVersions
func NewGetEventBrokerServiceVersionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/datacenters/%s/eventBrokerServiceVersions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionsRequest generates requests for GetVersions
func NewGetVersionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/defaultBrokerVersions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentRequest generates requests for GetEnvironment
func NewGetEnvironmentRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchEnvironmentRequest calls the generic PatchEnvironment builder with application/json body
func NewPatchEnvironmentRequest(server string, id string, body PatchEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchEnvironmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchEnvironmentRequestWithBody generates requests for PatchEnvironment with any type of body
func NewPatchEnvironmentRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string, params *GetServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomAttributes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customAttributes", runtime.ParamLocationQuery, *params.CustomAttributes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceRequest calls the generic CreateService builder with application/json body
func NewCreateServiceRequest(server string, body CreateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServiceRequestWithBody generates requests for CreateService with any type of body
func NewCreateServiceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceRequest generates requests for DeleteService
func NewDeleteServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, id string, params *GetServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Expand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expand", runtime.ParamLocationQuery, *params.Expand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceRequest calls the generic UpdateService builder with application/json body
func NewUpdateServiceRequest(server string, id string, body UpdateServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func NewUpdateServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCloneServiceRequest calls the generic CloneService builder with application/json body
func NewCloneServiceRequest(server string, id string, body CloneServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneServiceRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCloneServiceRequestWithBody generates requests for CloneService with any type of body
func NewCloneServiceRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clone", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResourceRequest generates requests for DeleteResource
func NewDeleteResourceRequest(server string, serviceId string, resourcePath string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourcePath", runtime.ParamLocationPath, resourcePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/broker/SEMP/v2/config/%s/**", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, serviceId string, resourcePath string, params *GetResourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourcePath", runtime.ParamLocationPath, resourcePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/broker/SEMP/v2/config/%s/**", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomQuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customQuery", runtime.ParamLocationQuery, *params.CustomQuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchResourceRequest calls the generic PatchResource builder with application/json body
func NewPatchResourceRequest(server string, serviceId string, resourcePath string, body PatchResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchResourceRequestWithBody(server, serviceId, resourcePath, "application/json", bodyReader)
}

// NewPatchResourceRequestWithBody generates requests for PatchResource with any type of body
func NewPatchResourceRequestWithBody(server string, serviceId string, resourcePath string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourcePath", runtime.ParamLocationPath, resourcePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/broker/SEMP/v2/config/%s/**", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateResourceRequest calls the generic CreateResource builder with application/json body
func NewCreateResourceRequest(server string, serviceId string, resourcePath string, body CreateResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResourceRequestWithBody(server, serviceId, resourcePath, "application/json", bodyReader)
}

// NewCreateResourceRequestWithBody generates requests for CreateResource with any type of body
func NewCreateResourceRequestWithBody(server string, serviceId string, resourcePath string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourcePath", runtime.ParamLocationPath, resourcePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/broker/SEMP/v2/config/%s/**", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceResourceRequest calls the generic ReplaceResource builder with application/json body
func NewReplaceResourceRequest(server string, serviceId string, resourcePath string, body ReplaceResourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceResourceRequestWithBody(server, serviceId, resourcePath, "application/json", bodyReader)
}

// NewReplaceResourceRequestWithBody generates requests for ReplaceResource with any type of body
func NewReplaceResourceRequestWithBody(server string, serviceId string, resourcePath string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourcePath", runtime.ParamLocationPath, resourcePath)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/broker/SEMP/v2/config/%s/**", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClientProfilesRequest generates requests for GetClientProfiles
func NewGetClientProfilesRequest(server string, serviceId string, params *GetClientProfilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClientProfileRequest calls the generic CreateClientProfile builder with application/json body
func NewCreateClientProfileRequest(server string, serviceId string, body CreateClientProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientProfileRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewCreateClientProfileRequestWithBody generates requests for CreateClientProfile with any type of body
func NewCreateClientProfileRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClientProfileRequest generates requests for DeleteClientProfile
func NewDeleteClientProfileRequest(server string, serviceId string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientProfileRequest generates requests for GetClientProfile
func NewGetClientProfileRequest(server string, serviceId string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClientProfileRequest calls the generic UpdateClientProfile builder with application/json body
func NewUpdateClientProfileRequest(server string, serviceId string, name string, body UpdateClientProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClientProfileRequestWithBody(server, serviceId, name, "application/json", bodyReader)
}

// NewUpdateClientProfileRequestWithBody generates requests for UpdateClientProfile with any type of body
func NewUpdateClientProfileRequestWithBody(server string, serviceId string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceClientProfileRequest calls the generic ReplaceClientProfile builder with application/json body
func NewReplaceClientProfileRequest(server string, serviceId string, name string, body ReplaceClientProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceClientProfileRequestWithBody(server, serviceId, name, "application/json", bodyReader)
}

// NewReplaceClientProfileRequestWithBody generates requests for ReplaceClientProfile with any type of body
func NewReplaceClientProfileRequestWithBody(server string, serviceId string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/clientProfiles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateMessageSpoolRequest calls the generic UpdateMessageSpool builder with application/json body
func NewUpdateMessageSpoolRequest(server string, serviceId string, body UpdateMessageSpoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMessageSpoolRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewUpdateMessageSpoolRequestWithBody generates requests for UpdateMessageSpool with any type of body
func NewUpdateMessageSpoolRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/messageSpool", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServiceOperationRequest generates requests for GetServiceOperation
func NewGetServiceOperationRequest(server string, serviceId string, operationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "operationId", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDisableOrEnableRequest calls the generic DisableOrEnable builder with application/json body
func NewDisableOrEnableRequest(server string, serviceId string, body DisableOrEnableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableOrEnableRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewDisableOrEnableRequestWithBody generates requests for DisableOrEnable with any type of body
func NewDisableOrEnableRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/sempBasicAuth", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerCertificatesRequest generates requests for GetAllServerCertificates
func NewGetAllServerCertificatesRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadServerCertificateRequest calls the generic UploadServerCertificate builder with application/json body
func NewUploadServerCertificateRequest(server string, serviceId string, body UploadServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadServerCertificateRequestWithBody(server, serviceId, "application/json", bodyReader)
}

// NewUploadServerCertificateRequestWithBody generates requests for UploadServerCertificate with any type of body
func NewUploadServerCertificateRequestWithBody(server string, serviceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/serverCertificates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerCertificateByIdRequest generates requests for DeleteServerCertificateById
func NewDeleteServerCertificateByIdRequest(server string, serviceId string, certificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "certificateId", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerCertificateByIdRequest generates requests for GetServerCertificateById
func NewGetServerCertificateByIdRequest(server string, serviceId string, certificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "certificateId", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/serverCertificates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallServerCertificateRequest calls the generic InstallServerCertificate builder with application/json body
func NewInstallServerCertificateRequest(server string, serviceId string, certificateId string, body InstallServerCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallServerCertificateRequestWithBody(server, serviceId, certificateId, "application/json", bodyReader)
}

// NewInstallServerCertificateRequestWithBody generates requests for InstallServerCertificate with any type of body
func NewInstallServerCertificateRequestWithBody(server string, serviceId string, certificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "certificateId", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/eventBrokerServices/%s/serverCertificates/%s/install", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLimitsRequest generates requests for GetLimits
func NewGetLimitsRequest(server string, orgId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgId", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/organizations/%s/messageSpoolLimitUsage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceClassesRequest generates requests for GetServiceClasses
func NewGetServiceClassesRequest(server string, params *GetServiceClassesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/serviceClasses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BrokerFamilyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brokerFamilyVersion", runtime.ParamLocationQuery, *params.BrokerFamilyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceClassRequest generates requests for GetServiceClass
func NewGetServiceClassRequest(server string, id GetServiceClassParamsId, params *GetServiceClassParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/missionControl/serviceClasses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BrokerFamilyVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brokerFamilyVersion", runtime.ParamLocationQuery, *params.BrokerFamilyVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDatacentersWithResponse request
	GetDatacentersWithResponse(ctx context.Context, params *GetDatacentersParams, reqEditors ...RequestEditorFn) (*GetDatacentersResponse, error)

	// GetDatacenterWithResponse request
	GetDatacenterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatacenterResponse, error)

	// UpdateDatacenterWithBodyWithResponse request with any body
	UpdateDatacenterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatacenterResponse, error)

	UpdateDatacenterWithResponse(ctx context.Context, id string, body UpdateDatacenterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatacenterResponse, error)

	// GetEventBrokerServiceVersionsWithResponse request
	GetEventBrokerServiceVersionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEventBrokerServiceVersionsResponse, error)

	// GetVersionsWithResponse request
	GetVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionsResponse, error)

	// GetEnvironmentWithResponse request
	GetEnvironmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error)

	// PatchEnvironmentWithBodyWithResponse request with any body
	PatchEnvironmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentResponse, error)

	PatchEnvironmentWithResponse(ctx context.Context, id string, body PatchEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentResponse, error)

	// GetServicesWithResponse request
	GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// CreateServiceWithBodyWithResponse request with any body
	CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error)

	// DeleteServiceWithResponse request
	DeleteServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error)

	// GetServiceWithResponse request
	GetServiceWithResponse(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// UpdateServiceWithBodyWithResponse request with any body
	UpdateServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	UpdateServiceWithResponse(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error)

	// CloneServiceWithBodyWithResponse request with any body
	CloneServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneServiceResponse, error)

	CloneServiceWithResponse(ctx context.Context, id string, body CloneServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneServiceResponse, error)

	// DeleteResourceWithResponse request
	DeleteResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// PatchResourceWithBodyWithResponse request with any body
	PatchResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchResourceResponse, error)

	PatchResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body PatchResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchResourceResponse, error)

	// CreateResourceWithBodyWithResponse request with any body
	CreateResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	CreateResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error)

	// ReplaceResourceWithBodyWithResponse request with any body
	ReplaceResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResourceResponse, error)

	ReplaceResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body ReplaceResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResourceResponse, error)

	// GetClientProfilesWithResponse request
	GetClientProfilesWithResponse(ctx context.Context, serviceId string, params *GetClientProfilesParams, reqEditors ...RequestEditorFn) (*GetClientProfilesResponse, error)

	// CreateClientProfileWithBodyWithResponse request with any body
	CreateClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientProfileResponse, error)

	CreateClientProfileWithResponse(ctx context.Context, serviceId string, body CreateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientProfileResponse, error)

	// DeleteClientProfileWithResponse request
	DeleteClientProfileWithResponse(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*DeleteClientProfileResponse, error)

	// GetClientProfileWithResponse request
	GetClientProfileWithResponse(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*GetClientProfileResponse, error)

	// UpdateClientProfileWithBodyWithResponse request with any body
	UpdateClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientProfileResponse, error)

	UpdateClientProfileWithResponse(ctx context.Context, serviceId string, name string, body UpdateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientProfileResponse, error)

	// ReplaceClientProfileWithBodyWithResponse request with any body
	ReplaceClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceClientProfileResponse, error)

	ReplaceClientProfileWithResponse(ctx context.Context, serviceId string, name string, body ReplaceClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceClientProfileResponse, error)

	// UpdateMessageSpoolWithBodyWithResponse request with any body
	UpdateMessageSpoolWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMessageSpoolResponse, error)

	UpdateMessageSpoolWithResponse(ctx context.Context, serviceId string, body UpdateMessageSpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMessageSpoolResponse, error)

	// GetServiceOperationWithResponse request
	GetServiceOperationWithResponse(ctx context.Context, serviceId string, operationId string, reqEditors ...RequestEditorFn) (*GetServiceOperationResponse, error)

	// DisableOrEnableWithBodyWithResponse request with any body
	DisableOrEnableWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableOrEnableResponse, error)

	DisableOrEnableWithResponse(ctx context.Context, serviceId string, body DisableOrEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableOrEnableResponse, error)

	// GetAllServerCertificatesWithResponse request
	GetAllServerCertificatesWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetAllServerCertificatesResponse, error)

	// UploadServerCertificateWithBodyWithResponse request with any body
	UploadServerCertificateWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadServerCertificateResponse, error)

	UploadServerCertificateWithResponse(ctx context.Context, serviceId string, body UploadServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadServerCertificateResponse, error)

	// DeleteServerCertificateByIdWithResponse request
	DeleteServerCertificateByIdWithResponse(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateByIdResponse, error)

	// GetServerCertificateByIdWithResponse request
	GetServerCertificateByIdWithResponse(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*GetServerCertificateByIdResponse, error)

	// InstallServerCertificateWithBodyWithResponse request with any body
	InstallServerCertificateWithBodyWithResponse(ctx context.Context, serviceId string, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallServerCertificateResponse, error)

	InstallServerCertificateWithResponse(ctx context.Context, serviceId string, certificateId string, body InstallServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallServerCertificateResponse, error)

	// GetLimitsWithResponse request
	GetLimitsWithResponse(ctx context.Context, orgId string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error)

	// GetServiceClassesWithResponse request
	GetServiceClassesWithResponse(ctx context.Context, params *GetServiceClassesParams, reqEditors ...RequestEditorFn) (*GetServiceClassesResponse, error)

	// GetServiceClassWithResponse request
	GetServiceClassWithResponse(ctx context.Context, id GetServiceClassParamsId, params *GetServiceClassParams, reqEditors ...RequestEditorFn) (*GetServiceClassResponse, error)
}

type GetDatacentersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatacentersResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetDatacentersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatacentersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatacenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatacenterResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetDatacenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatacenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatacenterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatacenterResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateDatacenterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatacenterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventBrokerServiceVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventBrokerServiceVersionsResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEventBrokerServiceVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventBrokerServiceVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventBrokerVersionsResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PatchEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceSummaryResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CloneServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *BrokerSempProxyError
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PatchResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *BrokerSempProxyError
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *BrokerSempProxyError
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReplaceResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientProfilesResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetClientProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateClientProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClientProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteClientProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClientProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientProfileResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetClientProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClientProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateClientProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClientProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceClientProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReplaceClientProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceClientProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMessageSpoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateMessageSpoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMessageSpoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableOrEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BasicAuthAvailabilityResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DisableOrEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableOrEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerCertificateSummaryResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAllServerCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadServerCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerCertificateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteServerCertificateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerCertificateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerCertificateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerCertificateResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServerCertificateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerCertificateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallServerCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *OperationResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r InstallServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessageSpoolLimitClassesResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceClassesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceClassesResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceClassesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceClassesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceClassResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceClassResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceClassResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceClassResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDatacentersWithResponse request returning *GetDatacentersResponse
func (c *ClientWithResponses) GetDatacentersWithResponse(ctx context.Context, params *GetDatacentersParams, reqEditors ...RequestEditorFn) (*GetDatacentersResponse, error) {
	rsp, err := c.GetDatacenters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatacentersResponse(rsp)
}

// GetDatacenterWithResponse request returning *GetDatacenterResponse
func (c *ClientWithResponses) GetDatacenterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDatacenterResponse, error) {
	rsp, err := c.GetDatacenter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatacenterResponse(rsp)
}

// UpdateDatacenterWithBodyWithResponse request with arbitrary body returning *UpdateDatacenterResponse
func (c *ClientWithResponses) UpdateDatacenterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatacenterResponse, error) {
	rsp, err := c.UpdateDatacenterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatacenterResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatacenterWithResponse(ctx context.Context, id string, body UpdateDatacenterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatacenterResponse, error) {
	rsp, err := c.UpdateDatacenter(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatacenterResponse(rsp)
}

// GetEventBrokerServiceVersionsWithResponse request returning *GetEventBrokerServiceVersionsResponse
func (c *ClientWithResponses) GetEventBrokerServiceVersionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEventBrokerServiceVersionsResponse, error) {
	rsp, err := c.GetEventBrokerServiceVersions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventBrokerServiceVersionsResponse(rsp)
}

// GetVersionsWithResponse request returning *GetVersionsResponse
func (c *ClientWithResponses) GetVersionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionsResponse, error) {
	rsp, err := c.GetVersions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionsResponse(rsp)
}

// GetEnvironmentWithResponse request returning *GetEnvironmentResponse
func (c *ClientWithResponses) GetEnvironmentWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error) {
	rsp, err := c.GetEnvironment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentResponse(rsp)
}

// PatchEnvironmentWithBodyWithResponse request with arbitrary body returning *PatchEnvironmentResponse
func (c *ClientWithResponses) PatchEnvironmentWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchEnvironmentResponse, error) {
	rsp, err := c.PatchEnvironmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) PatchEnvironmentWithResponse(ctx context.Context, id string, body PatchEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchEnvironmentResponse, error) {
	rsp, err := c.PatchEnvironment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchEnvironmentResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// CreateServiceWithBodyWithResponse request with arbitrary body returning *CreateServiceResponse
func (c *ClientWithResponses) CreateServiceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateServiceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceWithResponse(ctx context.Context, body CreateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceResponse, error) {
	rsp, err := c.CreateService(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceResponse(rsp)
}

// DeleteServiceWithResponse request returning *DeleteServiceResponse
func (c *ClientWithResponses) DeleteServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error) {
	rsp, err := c.DeleteService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// UpdateServiceWithBodyWithResponse request with arbitrary body returning *UpdateServiceResponse
func (c *ClientWithResponses) UpdateServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceWithResponse(ctx context.Context, id string, body UpdateServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceResponse, error) {
	rsp, err := c.UpdateService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceResponse(rsp)
}

// CloneServiceWithBodyWithResponse request with arbitrary body returning *CloneServiceResponse
func (c *ClientWithResponses) CloneServiceWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneServiceResponse, error) {
	rsp, err := c.CloneServiceWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneServiceResponse(rsp)
}

func (c *ClientWithResponses) CloneServiceWithResponse(ctx context.Context, id string, body CloneServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneServiceResponse, error) {
	rsp, err := c.CloneService(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneServiceResponse(rsp)
}

// DeleteResourceWithResponse request returning *DeleteResourceResponse
func (c *ClientWithResponses) DeleteResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, reqEditors ...RequestEditorFn) (*DeleteResourceResponse, error) {
	rsp, err := c.DeleteResource(ctx, serviceId, resourcePath, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResourceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, params *GetResourceParams, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, serviceId, resourcePath, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// PatchResourceWithBodyWithResponse request with arbitrary body returning *PatchResourceResponse
func (c *ClientWithResponses) PatchResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchResourceResponse, error) {
	rsp, err := c.PatchResourceWithBody(ctx, serviceId, resourcePath, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchResourceResponse(rsp)
}

func (c *ClientWithResponses) PatchResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body PatchResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchResourceResponse, error) {
	rsp, err := c.PatchResource(ctx, serviceId, resourcePath, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchResourceResponse(rsp)
}

// CreateResourceWithBodyWithResponse request with arbitrary body returning *CreateResourceResponse
func (c *ClientWithResponses) CreateResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResourceWithBody(ctx, serviceId, resourcePath, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

func (c *ClientWithResponses) CreateResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body CreateResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResourceResponse, error) {
	rsp, err := c.CreateResource(ctx, serviceId, resourcePath, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResourceResponse(rsp)
}

// ReplaceResourceWithBodyWithResponse request with arbitrary body returning *ReplaceResourceResponse
func (c *ClientWithResponses) ReplaceResourceWithBodyWithResponse(ctx context.Context, serviceId string, resourcePath string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResourceResponse, error) {
	rsp, err := c.ReplaceResourceWithBody(ctx, serviceId, resourcePath, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResourceResponse(rsp)
}

func (c *ClientWithResponses) ReplaceResourceWithResponse(ctx context.Context, serviceId string, resourcePath string, body ReplaceResourceJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResourceResponse, error) {
	rsp, err := c.ReplaceResource(ctx, serviceId, resourcePath, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResourceResponse(rsp)
}

// GetClientProfilesWithResponse request returning *GetClientProfilesResponse
func (c *ClientWithResponses) GetClientProfilesWithResponse(ctx context.Context, serviceId string, params *GetClientProfilesParams, reqEditors ...RequestEditorFn) (*GetClientProfilesResponse, error) {
	rsp, err := c.GetClientProfiles(ctx, serviceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientProfilesResponse(rsp)
}

// CreateClientProfileWithBodyWithResponse request with arbitrary body returning *CreateClientProfileResponse
func (c *ClientWithResponses) CreateClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientProfileResponse, error) {
	rsp, err := c.CreateClientProfileWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateClientProfileWithResponse(ctx context.Context, serviceId string, body CreateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientProfileResponse, error) {
	rsp, err := c.CreateClientProfile(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientProfileResponse(rsp)
}

// DeleteClientProfileWithResponse request returning *DeleteClientProfileResponse
func (c *ClientWithResponses) DeleteClientProfileWithResponse(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*DeleteClientProfileResponse, error) {
	rsp, err := c.DeleteClientProfile(ctx, serviceId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClientProfileResponse(rsp)
}

// GetClientProfileWithResponse request returning *GetClientProfileResponse
func (c *ClientWithResponses) GetClientProfileWithResponse(ctx context.Context, serviceId string, name string, reqEditors ...RequestEditorFn) (*GetClientProfileResponse, error) {
	rsp, err := c.GetClientProfile(ctx, serviceId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientProfileResponse(rsp)
}

// UpdateClientProfileWithBodyWithResponse request with arbitrary body returning *UpdateClientProfileResponse
func (c *ClientWithResponses) UpdateClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClientProfileResponse, error) {
	rsp, err := c.UpdateClientProfileWithBody(ctx, serviceId, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateClientProfileWithResponse(ctx context.Context, serviceId string, name string, body UpdateClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClientProfileResponse, error) {
	rsp, err := c.UpdateClientProfile(ctx, serviceId, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClientProfileResponse(rsp)
}

// ReplaceClientProfileWithBodyWithResponse request with arbitrary body returning *ReplaceClientProfileResponse
func (c *ClientWithResponses) ReplaceClientProfileWithBodyWithResponse(ctx context.Context, serviceId string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceClientProfileResponse, error) {
	rsp, err := c.ReplaceClientProfileWithBody(ctx, serviceId, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceClientProfileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceClientProfileWithResponse(ctx context.Context, serviceId string, name string, body ReplaceClientProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceClientProfileResponse, error) {
	rsp, err := c.ReplaceClientProfile(ctx, serviceId, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceClientProfileResponse(rsp)
}

// UpdateMessageSpoolWithBodyWithResponse request with arbitrary body returning *UpdateMessageSpoolResponse
func (c *ClientWithResponses) UpdateMessageSpoolWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMessageSpoolResponse, error) {
	rsp, err := c.UpdateMessageSpoolWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMessageSpoolResponse(rsp)
}

func (c *ClientWithResponses) UpdateMessageSpoolWithResponse(ctx context.Context, serviceId string, body UpdateMessageSpoolJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMessageSpoolResponse, error) {
	rsp, err := c.UpdateMessageSpool(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMessageSpoolResponse(rsp)
}

// GetServiceOperationWithResponse request returning *GetServiceOperationResponse
func (c *ClientWithResponses) GetServiceOperationWithResponse(ctx context.Context, serviceId string, operationId string, reqEditors ...RequestEditorFn) (*GetServiceOperationResponse, error) {
	rsp, err := c.GetServiceOperation(ctx, serviceId, operationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceOperationResponse(rsp)
}

// DisableOrEnableWithBodyWithResponse request with arbitrary body returning *DisableOrEnableResponse
func (c *ClientWithResponses) DisableOrEnableWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableOrEnableResponse, error) {
	rsp, err := c.DisableOrEnableWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableOrEnableResponse(rsp)
}

func (c *ClientWithResponses) DisableOrEnableWithResponse(ctx context.Context, serviceId string, body DisableOrEnableJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableOrEnableResponse, error) {
	rsp, err := c.DisableOrEnable(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableOrEnableResponse(rsp)
}

// GetAllServerCertificatesWithResponse request returning *GetAllServerCertificatesResponse
func (c *ClientWithResponses) GetAllServerCertificatesWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetAllServerCertificatesResponse, error) {
	rsp, err := c.GetAllServerCertificates(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerCertificatesResponse(rsp)
}

// UploadServerCertificateWithBodyWithResponse request with arbitrary body returning *UploadServerCertificateResponse
func (c *ClientWithResponses) UploadServerCertificateWithBodyWithResponse(ctx context.Context, serviceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadServerCertificateResponse, error) {
	rsp, err := c.UploadServerCertificateWithBody(ctx, serviceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) UploadServerCertificateWithResponse(ctx context.Context, serviceId string, body UploadServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadServerCertificateResponse, error) {
	rsp, err := c.UploadServerCertificate(ctx, serviceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadServerCertificateResponse(rsp)
}

// DeleteServerCertificateByIdWithResponse request returning *DeleteServerCertificateByIdResponse
func (c *ClientWithResponses) DeleteServerCertificateByIdWithResponse(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*DeleteServerCertificateByIdResponse, error) {
	rsp, err := c.DeleteServerCertificateById(ctx, serviceId, certificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerCertificateByIdResponse(rsp)
}

// GetServerCertificateByIdWithResponse request returning *GetServerCertificateByIdResponse
func (c *ClientWithResponses) GetServerCertificateByIdWithResponse(ctx context.Context, serviceId string, certificateId string, reqEditors ...RequestEditorFn) (*GetServerCertificateByIdResponse, error) {
	rsp, err := c.GetServerCertificateById(ctx, serviceId, certificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerCertificateByIdResponse(rsp)
}

// InstallServerCertificateWithBodyWithResponse request with arbitrary body returning *InstallServerCertificateResponse
func (c *ClientWithResponses) InstallServerCertificateWithBodyWithResponse(ctx context.Context, serviceId string, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallServerCertificateResponse, error) {
	rsp, err := c.InstallServerCertificateWithBody(ctx, serviceId, certificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallServerCertificateResponse(rsp)
}

func (c *ClientWithResponses) InstallServerCertificateWithResponse(ctx context.Context, serviceId string, certificateId string, body InstallServerCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallServerCertificateResponse, error) {
	rsp, err := c.InstallServerCertificate(ctx, serviceId, certificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallServerCertificateResponse(rsp)
}

// GetLimitsWithResponse request returning *GetLimitsResponse
func (c *ClientWithResponses) GetLimitsWithResponse(ctx context.Context, orgId string, reqEditors ...RequestEditorFn) (*GetLimitsResponse, error) {
	rsp, err := c.GetLimits(ctx, orgId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLimitsResponse(rsp)
}

// GetServiceClassesWithResponse request returning *GetServiceClassesResponse
func (c *ClientWithResponses) GetServiceClassesWithResponse(ctx context.Context, params *GetServiceClassesParams, reqEditors ...RequestEditorFn) (*GetServiceClassesResponse, error) {
	rsp, err := c.GetServiceClasses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceClassesResponse(rsp)
}

// GetServiceClassWithResponse request returning *GetServiceClassResponse
func (c *ClientWithResponses) GetServiceClassWithResponse(ctx context.Context, id GetServiceClassParamsId, params *GetServiceClassParams, reqEditors ...RequestEditorFn) (*GetServiceClassResponse, error) {
	rsp, err := c.GetServiceClass(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceClassResponse(rsp)
}

// ParseGetDatacentersResponse parses an HTTP response from a GetDatacentersWithResponse call
func ParseGetDatacentersResponse(rsp *http.Response) (*GetDatacentersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatacentersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatacentersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetDatacenterResponse parses an HTTP response from a GetDatacenterWithResponse call
func ParseGetDatacenterResponse(rsp *http.Response) (*GetDatacenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatacenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatacenterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateDatacenterResponse parses an HTTP response from a UpdateDatacenterWithResponse call
func ParseUpdateDatacenterResponse(rsp *http.Response) (*UpdateDatacenterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatacenterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatacenterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetEventBrokerServiceVersionsResponse parses an HTTP response from a GetEventBrokerServiceVersionsWithResponse call
func ParseGetEventBrokerServiceVersionsResponse(rsp *http.Response) (*GetEventBrokerServiceVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventBrokerServiceVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventBrokerServiceVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetVersionsResponse parses an HTTP response from a GetVersionsWithResponse call
func ParseGetVersionsResponse(rsp *http.Response) (*GetVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventBrokerVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 400:
		// Content-type (*/*) unsupported

	}

	return response, nil
}

// ParseGetEnvironmentResponse parses an HTTP response from a GetEnvironmentWithResponse call
func ParseGetEnvironmentResponse(rsp *http.Response) (*GetEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePatchEnvironmentResponse parses an HTTP response from a PatchEnvironmentWithResponse call
func ParsePatchEnvironmentResponse(rsp *http.Response) (*PatchEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateServiceResponse parses an HTTP response from a CreateServiceWithResponse call
func ParseCreateServiceResponse(rsp *http.Response) (*CreateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteServiceResponse parses an HTTP response from a DeleteServiceWithResponse call
func ParseDeleteServiceResponse(rsp *http.Response) (*DeleteServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateServiceResponse parses an HTTP response from a UpdateServiceWithResponse call
func ParseUpdateServiceResponse(rsp *http.Response) (*UpdateServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCloneServiceResponse parses an HTTP response from a CloneServiceWithResponse call
func ParseCloneServiceResponse(rsp *http.Response) (*CloneServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteResourceResponse parses an HTTP response from a DeleteResourceWithResponse call
func ParseDeleteResourceResponse(rsp *http.Response) (*DeleteResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePatchResourceResponse parses an HTTP response from a PatchResourceWithResponse call
func ParsePatchResourceResponse(rsp *http.Response) (*PatchResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BrokerSempProxyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateResourceResponse parses an HTTP response from a CreateResourceWithResponse call
func ParseCreateResourceResponse(rsp *http.Response) (*CreateResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BrokerSempProxyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReplaceResourceResponse parses an HTTP response from a ReplaceResourceWithResponse call
func ParseReplaceResourceResponse(rsp *http.Response) (*ReplaceResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BrokerSempProxyError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetClientProfilesResponse parses an HTTP response from a GetClientProfilesWithResponse call
func ParseGetClientProfilesResponse(rsp *http.Response) (*GetClientProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientProfilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCreateClientProfileResponse parses an HTTP response from a CreateClientProfileWithResponse call
func ParseCreateClientProfileResponse(rsp *http.Response) (*CreateClientProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteClientProfileResponse parses an HTTP response from a DeleteClientProfileWithResponse call
func ParseDeleteClientProfileResponse(rsp *http.Response) (*DeleteClientProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClientProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetClientProfileResponse parses an HTTP response from a GetClientProfileWithResponse call
func ParseGetClientProfileResponse(rsp *http.Response) (*GetClientProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateClientProfileResponse parses an HTTP response from a UpdateClientProfileWithResponse call
func ParseUpdateClientProfileResponse(rsp *http.Response) (*UpdateClientProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClientProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReplaceClientProfileResponse parses an HTTP response from a ReplaceClientProfileWithResponse call
func ParseReplaceClientProfileResponse(rsp *http.Response) (*ReplaceClientProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceClientProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseUpdateMessageSpoolResponse parses an HTTP response from a UpdateMessageSpoolWithResponse call
func ParseUpdateMessageSpoolResponse(rsp *http.Response) (*UpdateMessageSpoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMessageSpoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServiceOperationResponse parses an HTTP response from a GetServiceOperationWithResponse call
func ParseGetServiceOperationResponse(rsp *http.Response) (*GetServiceOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDisableOrEnableResponse parses an HTTP response from a DisableOrEnableWithResponse call
func ParseDisableOrEnableResponse(rsp *http.Response) (*DisableOrEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableOrEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BasicAuthAvailabilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllServerCertificatesResponse parses an HTTP response from a GetAllServerCertificatesWithResponse call
func ParseGetAllServerCertificatesResponse(rsp *http.Response) (*GetAllServerCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerCertificateSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadServerCertificateResponse parses an HTTP response from a UploadServerCertificateWithResponse call
func ParseUploadServerCertificateResponse(rsp *http.Response) (*UploadServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteServerCertificateByIdResponse parses an HTTP response from a DeleteServerCertificateByIdWithResponse call
func ParseDeleteServerCertificateByIdResponse(rsp *http.Response) (*DeleteServerCertificateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerCertificateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetServerCertificateByIdResponse parses an HTTP response from a GetServerCertificateByIdWithResponse call
func ParseGetServerCertificateByIdResponse(rsp *http.Response) (*GetServerCertificateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerCertificateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerCertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInstallServerCertificateResponse parses an HTTP response from a InstallServerCertificateWithResponse call
func ParseInstallServerCertificateResponse(rsp *http.Response) (*InstallServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLimitsResponse parses an HTTP response from a GetLimitsWithResponse call
func ParseGetLimitsResponse(rsp *http.Response) (*GetLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessageSpoolLimitClassesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 400:
		// Content-type (*/*) unsupported

	}

	return response, nil
}

// ParseGetServiceClassesResponse parses an HTTP response from a GetServiceClassesWithResponse call
func ParseGetServiceClassesResponse(rsp *http.Response) (*GetServiceClassesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceClassesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceClassesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetServiceClassResponse parses an HTTP response from a GetServiceClassWithResponse call
func ParseGetServiceClassResponse(rsp *http.Response) (*GetServiceClassResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceClassResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceClassResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}
